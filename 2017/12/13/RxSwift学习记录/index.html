<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Observable在RxSwift中，最关键的一个概念是可观察序列（Observable Sequence），它相当于Swift中的序列（Sequence），可观察序列中的每个元素都是一个事件，我们知道Swift的序列中可以包含任意多个元素，类似的，可观察序列会不断产生新的事件直到发生错误或正常结束为止。订阅者（Observer）通过订阅（subscribe）一个可观察队列来接收序列所产生的新事">
<meta property="og:type" content="article">
<meta property="og:title" content="RxSwift学习记录">
<meta property="og:url" content="http://yoursite.com/2017/12/13/RxSwift学习记录/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Observable在RxSwift中，最关键的一个概念是可观察序列（Observable Sequence），它相当于Swift中的序列（Sequence），可观察序列中的每个元素都是一个事件，我们知道Swift的序列中可以包含任意多个元素，类似的，可观察序列会不断产生新的事件直到发生错误或正常结束为止。订阅者（Observer）通过订阅（subscribe）一个可观察队列来接收序列所产生的新事">
<meta property="og:updated_time" content="2017-12-13T10:43:50.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RxSwift学习记录">
<meta name="twitter:description" content="Observable在RxSwift中，最关键的一个概念是可观察序列（Observable Sequence），它相当于Swift中的序列（Sequence），可观察序列中的每个元素都是一个事件，我们知道Swift的序列中可以包含任意多个元素，类似的，可观察序列会不断产生新的事件直到发生错误或正常结束为止。订阅者（Observer）通过订阅（subscribe）一个可观察队列来接收序列所产生的新事">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/13/RxSwift学习记录/"/>





  <title>RxSwift学习记录 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/13/RxSwift学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">RxSwift学习记录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-13T18:35:13+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>在RxSwift中，最关键的一个概念是可观察序列（Observable Sequence），它相当于Swift中的序列（Sequence），可观察序列中的每个元素都是一个事件，我们知道Swift的序列中可以包含任意多个元素，类似的，可观察序列会不断产生新的事件直到发生错误或正常结束为止。订阅者（Observer）通过订阅（subscribe）一个可观察队列来接收序列所产生的新事件，只有在有观察者的情况下序列才可以发送事件。</p>
<p>例如，使用<code>of</code>操作创建一个可观察序列（以下简称为Observable）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>of</code>是一种用来创建Observable的简便操作，在上面的代码中创建了一个类型为<code>Observable&lt;Int&gt;</code>的Observable，里面包含了三个元素：1，2，3。</p>
<p>来看看Observable中都提供了哪些操作，可观察序列是一个实现了<code>ObservableType</code>协议的类型，<code>ObservableType</code>协议的定义非常简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObservableType</span> : <span class="title">ObservableConvertibleType</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">E</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: O)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>E</code>是一个关联类型，表示序列中元素的类型，除此之外协议只定义了一个方法：<code>subscribe</code>，用于向可观察序列添加一个观察者（<code>ObserverType</code>类型）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收闭包的subscribe函数是通过协议扩展提供的简便方法</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>subscribe</code>相当于Swift序列中的遍历操作（makeIterator），如上，向seq序列添加一个观察者，在序列中有新的事件时调用该闭包，上面的代码会输出1，2，3。</p>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>观察者是实现了<code>ObserverType</code>协议的对象，<code>ObserverType</code>协议同样十分简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">E</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;E&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>E</code>为观察者所观察序列中的元素类型，当序列中有新的事件产生时，会调用<code>on</code>方法来接收新的事件。其中事件的类型<code>Event</code>是一个枚举，其中包含3个类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> next(<span class="type">Element</span>)</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>.next</code>：表示序列中产生了下一个事件，关联值Element保存了该事件的值。</li>
<li><code>.error</code>：序列产生了一个错误，关联值Error保存了错误类型，在这之后序列会直接结束(不再产生新的next事件)。</li>
<li><code>.completed</code>：序列正常结束。</li>
</ol>
<h2 id="Dispose"><a href="#Dispose" class="headerlink" title="Dispose"></a>Dispose</h2><p>除了产生错误和自然结束以外，还可以手动结束观察，在使用<code>subscribe</code>订阅一个可观察序列时，会返回一个<code>Disposable</code>类型的对象。这里的<code>Disposable</code>是一个协议，只定义了一个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispose</code>方法用来结束此次订阅并释放可观察序列中的相关资源，通常来说你并不需要直接调用该方法，而是通过调用其扩展方法<code>addDisposableTo</code>将<code>Disposable</code>添加到一个<code>DisposeBag</code>对象中。DisposeBag对象会自动管理所有添加到其中的Disposable对象，在DisposeBag对象销毁的时候会自动调用其中所有Disposable的dispose方法释放资源。</p>
<p>也可以使用<code>takeUntil</code>来自动结束订阅：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq.takeUntil(otherSeq)</span><br><span class="line">	.subscribe(&#123; (event) <span class="keyword">in</span></span><br><span class="line">    	<span class="built_in">print</span>(event)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>在otherSeq序列发出任意类型的事件之后，自动结束本次订阅。</p>
<h2 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h2><p>通过<code>Observable</code>类型提供的方法<code>create</code>可以创建一个自定义的可观察序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.on(.next(<span class="number">1</span>))</span><br><span class="line">    observer.on(.completed)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;</span><br><span class="line">        <span class="comment">// do some cleanup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create</code>方法使用一个闭包来创建自定义的序列，闭包接收一个<code>ObserverType</code>的参数observer，并通过observer来发送相应的事件。如上面的代码，创建了一个<code>Observable&lt;Int&gt;</code>类型的可观察序列，订阅该序列的观察者会收到事件1和一个完成事件。最后<code>create</code>方法返回一个自己创建的<code>Disposable</code>对象，可以在这里进行一些相关的资源回收操作。</p>
<p>除了<code>create</code>方法之外，RxSwift中提供了很多中简便的方法用于创建序列，常用的有：</p>
<ul>
<li><p><strong>just</strong>：创建一个只包含一个值的可观察序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> justSeq = <span class="type">Observable</span>.just(<span class="number">1</span>)</span><br><span class="line">justSeq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>of</strong>：<code>of</code>和<code>just</code>有点类似，不同的是<code>of</code>可以将一系列元素创建成事件队列，该<code>Observable</code>依次发送相应事件和结束事件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ofSeq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">ofSeq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>empty</strong>：这种类型的Observable只发送结束(Completed)事件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptySequence = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.empty()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>error</strong>：该队列只发送一个<code>error</code>事件，传递一个自定义的错误类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> errorSeq = <span class="type">Observable</span>&lt;<span class="type">TestError</span>&gt;.error(<span class="type">TestError</span>.<span class="type">Error1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>通常在我们在订阅一个可观察序列的时候，每一次的订阅行为都是独立的，也就是说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 1: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 2: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">1</span>)</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">2</span>)</span><br><span class="line">sub <span class="number">1</span>: completed </span><br><span class="line">sub <span class="number">2</span>: next(<span class="number">1</span>)</span><br><span class="line">sub <span class="number">2</span>: next(<span class="number">2</span>)</span><br><span class="line">sub <span class="number">2</span>: completed</span><br></pre></td></tr></table></figure>
<p>我们连续订阅同一序列两次，每次都会接收到相同的事件，第二次订阅时并没有因为第一次订阅的行为导致元素”耗尽”。有些时候我们希望让所有的观察者都共享同一份事件，这个时候可以使用<code>share</code></p>
<ul>
<li><p><strong>share</strong>：<code>share</code>是<code>ObservableType</code>协议的一个扩展方法，它返回一个可观察序列，该序列的所有观察者都会共享同一份订阅，上面的代码加上share之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>).share()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 1: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 2: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">1</span>)</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">2</span>)</span><br><span class="line">sub <span class="number">1</span>: completed </span><br><span class="line">sub <span class="number">2</span>: completed</span><br></pre></td></tr></table></figure>
<p>可以看到，在第一次订阅时序列已经将所有的事件发送，后面再进行第二次订阅的时候只收到了一个完成事件。</p>
</li>
<li><p><strong>shareReplay</strong>：<code>shareReplay</code>的用法与<code>share</code>类似，它的方法签名如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shareReplay</span><span class="params">(<span class="number">_</span> bufferSize: Int)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;</span><br></pre></td></tr></table></figure>
<p>不同的地方在于，<code>shareReplay</code>接收一个整型参数bufferSize，指定缓冲区大小，订阅该序列的观察者会立即收到最近bufferSize条事件。</p>
</li>
</ul>
<h2 id="序列的变换和组合"><a href="#序列的变换和组合" class="headerlink" title="序列的变换和组合"></a>序列的变换和组合</h2><p>在Swift的序列<code>Sequence</code>中，可以使用map、flatMap和reduce等常见的函数式方法对其中的元素进行变换，RxSwift中的可观察序列同样也支持这些方法。</p>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul>
<li><p><strong>map</strong>：这是<code>map</code>方法的签名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在一个自定义的闭包中对序列的每一个元素进行变换，返回一个包含转换后结果的可观察序列，与Swift中<code>Sequence</code>的map类似。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mappedSeq: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = seq.<span class="built_in">map</span> &#123; (element) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"value: <span class="subst">\(element)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>flatMap</strong>：先来看看<code>flatMap</code>的签名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;O: ObservableConvertibleType&gt;<span class="params">(<span class="number">_</span> selector: @escaping <span class="params">(E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">O</span>)</span><br><span class="line">        -&gt; <span class="type">Observable</span>&lt;<span class="type">O</span>.<span class="type">E</span>&gt;</span><br></pre></td></tr></table></figure>
<p>关于flatMap的作用同样可以类比<code>Sequence</code>，<code>Sequence</code>中的<code>flatMap</code>闭包遍历每一个元素进行处理后返回一个新的序列，最后会将这些序列”展平”，得到一个包含所有序列元素的新序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> res = array.flatMap &#123; (n) -&gt; [<span class="type">String</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"<span class="subst">\(n)</span>a"</span>, <span class="string">"<span class="subst">\(n)</span>b"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// res: ["1a", "1b", "2a", "2b"]</span></span><br></pre></td></tr></table></figure>
<p>RxSwift中的<code>flatMap</code>用法与之类似，<code>flatMap</code>中的闭包会遍历可观察序列中的所有元素，并返回一个新的可观察序列，最后<code>flatMap</code>会返回一个包含所有元素的可观察序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .flatMap &#123; (n) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="string">"<span class="subst">\(n)</span>a"</span>, <span class="string">"<span class="subst">\(n)</span>b"</span>) <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 得到的seq类型为Observable&lt;String&gt;</span></span><br><span class="line">---- example output ----</span><br><span class="line">next(1a)</span><br><span class="line">next(1b)</span><br><span class="line">next(2a)</span><br><span class="line">next(2b)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>在闭包中创建了若干个可观察序列(1)，这些序列中发送的<code>next</code>事件都会被传递到seq序列中，其中任何一个序列发生错误（发送了<code>error</code>事件）时，seq序列都会直接结束，不再继续接收事件；但是只有所有序列都完成（发送了<code>completed</code>事件）后，seq序列才会正常结束。</p>
</li>
<li><p><strong>flatMapLatest</strong>：作用与<code>flatMap</code>类似，但是对于闭包中生成的可观察序列，它并不会保留所有的序列的订阅，在遍历结束后，只保留最后创建的序列的订阅，之前创建的Observables都会取消订阅（相应序列的dispose方法也会被调用）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与上一个例子相同的代码，仅将flatMap改成flatMapLatest</span></span><br><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .flatMapLatest &#123; (n) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="string">"<span class="subst">\(n)</span>a"</span>, <span class="string">"<span class="subst">\(n)</span>b"</span>) <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(1a)</span><br><span class="line">next(2a)</span><br><span class="line">next(2b)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>因为订阅关系的改变，现在只有当最后创建的那个Observable正常结束时，seq才会收到<code>completed</code>事件。</p>
<p>在这种情况下，<code>flatMapLatest</code>会得到与<code>flatMap</code>相同的输出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .flatMapLatest &#123; (n) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create(&#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            observer.onNext(<span class="string">"<span class="subst">\(n)</span>a"</span>)</span><br><span class="line">            observer.onNext(<span class="string">"<span class="subst">\(n)</span>b"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这是因为在上面的这个例子中所创建的Observable是同步创建元素的，无法被打断。</p>
<p>类似的方法还有<code>flatMapFirst</code>，使用方法可以类比<code>flatMapLatest</code>。</p>
</li>
<li><p><strong>reduce和scan</strong>：<code>reduce</code>的作用与Sequence中定义的一样，它接收一个初始值和一个闭包，在Observable中的每个值上调用该闭包，并将每一步的结果作为下一次调用的输入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; (first, num) -&gt; <span class="type">Float</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Float</span>(first + num)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出：next(6.0), completed</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，提供了一个初始值0，在闭包中计算和，并将结果序列的元素类型改成<code>Float</code>，序列的观察者最后接收到所有元素的和。</p>
<p><code>scan</code>的作用类似于<code>reduce</code>，它跟<code>reduce</code>之间唯一的区别在于，<code>scan</code>会发送每一次调用闭包后的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).scan(<span class="number">0</span>) &#123; (first, num) -&gt; <span class="type">Float</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Float</span>(first + num)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出：next(1.0), next(3.0), next(6.0), completed</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul>
<li><p><strong>startWith</strong>：在序列的开头加入一个指定的元素</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">3</span>).startWith(<span class="number">1</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>订阅该序列之后，会立即收到<code>startWith</code>指定的事件，即使此时序列并没有开始发送事件。</p>
</li>
<li><p><strong>merge</strong>：当你有多个类型相同的Observable，可以使用<code>merge</code>方法将它们合并起来，同时订阅所有Observable中的事件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq1 = <span class="type">Observable</span>.just(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> seq2 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(seq1, seq2).merge()</span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>只有当Observable中的元素也是Observable类型的时候才可以使用<code>merge</code>方法，当其中一个序列发生错误的时候，seq都会被终止，同样的只有所有序列都完成之后，seq才会收到完成事件。</p>
</li>
<li><p><strong>zip</strong>：<code>zip</code>方法也可以将多个Observable合并在一起，与<code>merge</code>不同的是，<code>zip</code>提供了一个闭包用来对多个Observable中的元素进行组合变化，最后获得一个新的序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq1 = <span class="type">Observable</span>.just(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> seq2 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> seq: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = <span class="type">Observable</span>.<span class="built_in">zip</span>(seq1, seq2) &#123; (num1, num2) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">\(num1 + num2)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p><code>zip</code>方法按照参数个数的不同有多个版本，最多支持合并8个可观察序列，需要注意的一点是，闭包所接收的参数是各个序列中对应位置的元素。也就是说，如果seq1发送了一个事件，而seq2发送了多个事件，闭包也只会被执行一次，seq中只有一个元素。</p>
<p>组合的Observable中任意一个发生错误，最后的seq都会直接出错终止，当所有的Observable都发出completed事件后，seq才会正常结束。</p>
</li>
<li><p><strong>combineLatest</strong>：<code>combineLatest</code>同样用于将多个序列组合成一个，使用方法与<code>zip</code>一样，但是它的调用机制跟<code>zip</code>不同，每当其中一个序列有新元素时，<code>combineLatest</code>都会从其他所有序列中取出最后一个元素，传入闭包中生成新的元素添加到结果序列中。</p>
</li>
</ul>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p><code>Subject</code>对象相当于一种中间的代理和桥梁的作用，它既是观察者又是可观察序列，在向一个<code>Subject</code>对象添加观察者之后，可以通过该<code>Subject</code>向其发送事件。<code>Subject</code>对象并不会主动发送completed事件，并且在发送了error或completed事件之后，<code>Subject</code>中的序列会直接终结，无法再发送新的消息。<code>Subject</code>同样也分为几种类型：</p>
<ul>
<li><p><strong>PublishSubject</strong>：<code>PublishSubject</code>的订阅者只会收到在其订阅（subscribe）之后发送的事件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">subject.onNext(<span class="number">1</span>)</span><br><span class="line">subject.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">subject.onNext(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，观察者只收到了事件2，在订阅之前发送的事件1并没有接收到。</p>
</li>
<li><p><strong>ReplaySubject</strong>：<code>ReplaySubject</code>在初始化时指定一个大小为n的缓冲区，里面会保存最近发送的n条事件，在订阅之后，观察者会立即收到缓冲区中的事件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">Int</span>&gt;.create(bufferSize: <span class="number">2</span>)</span><br><span class="line">subject.onNext(<span class="number">1</span>)</span><br><span class="line">subject.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">subject.onNext(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>BehaviorSubject</strong>：<code>BehaviorSubject</code>在初始化时需要提供一个默认值，在订阅时观察者会立刻收到序列上一次发送的事件，如果没有发送过事件则会收到默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="number">1</span>)</span><br><span class="line">subject.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Variable</strong>：<code>Variable</code>是对<code>BehaviorSubject</code>的一个封装，行为上与<code>BehaviorSubject</code>类似。<code>Variable</code>没有<code>on</code>之类的方法来发送事件，取而代之的是一个<code>value</code>属性，向<code>value</code>赋值可以向观察者发送next事件，并且访问<code>value</code>可以获取最后一次发送的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(<span class="number">1</span>)</span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">variable.value = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>与其他Subject类型不同的是，<code>Variable</code>在释放的时候会发送completed事件，并且<code>Variable</code>对象永远不会发送error事件。</p>
</li>
</ul>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p><code>Scheduler</code>是RxSwift中进行多线程编程的一种方式，一个Observable在执行的时候会指定一个<code>Scheduler</code>，这个<code>Scheduler</code>决定了在哪个线程对序列进行操作以及事件回调。默认情况下，在订阅Observable之后，观察者会在与调用<code>subscribe</code>方法时相同的线程收到通知，并且也会在该线程进行销毁（dispose）。</p>
<p>与GCD类似，<code>Scheduler</code>分为串行（serial）和并行（concurrent）两种类型，RxSwift中定义了几种Schedular：</p>
<ul>
<li><strong>CurrentThreadScheduler</strong>：这是默认的Scheduler，代表了当前的线程，serial类型。</li>
<li><strong>MainScheduler</strong>：表示主线程，serial类型</li>
<li><strong>SerialDispatchQueueScheduler</strong>：提供了一些快捷的方法来创建串行Scheduler，内部封装了DispatchQueue</li>
<li><strong>ConcurrentDispatchQueueScheduler</strong>：提供了快捷的方法来创建并行Scheduler，同样封装了DispatchQueue</li>
</ul>
<h3 id="subscribeOn和observeOn"><a href="#subscribeOn和observeOn" class="headerlink" title="subscribeOn和observeOn"></a>subscribeOn和observeOn</h3><p><code>subscribeOn</code>和<code>observeOn</code>是其中两个最重要的方法，它们可以改变Observable所在的Scheduler：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main thread</span></span><br><span class="line"><span class="keyword">let</span> scheduler = <span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .<span class="keyword">default</span>)</span><br><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">seq.subscribeOn(scheduler)</span><br><span class="line">    .<span class="built_in">map</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">0</span> * <span class="number">2</span> <span class="comment">// 子线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event) <span class="comment">// 子线程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中创建了一个并发的Scheduler，并在序列seq上调用<code>subscribeOn</code>指定了该Scheduler，可以看到，我们在主线程中订阅该序列，但是<code>map</code>方法以及事件的回调都是在创建的子线程中执行。</p>
<p><code>subscribeOn</code>和<code>observeOn</code>都可以指定序列的Scheduler，它们之间的区别在于：</p>
<ul>
<li><code>subscribeOn</code>设定了整个序列开始的时候所在的Scheduler，序列在创建以及之后的操作都会在这个Scheduler上进行，<code>subscribeOn</code>在整个链式调用中只能调用一次，之后再次调用<code>subscribeOn</code>没有任何效果。</li>
<li><code>observeOn</code>指定一个Scheduler，在这之后的操作都会被派发到这个Scheduler上执行，<code>observeOn</code>可以在链式操作的中间改变Scheduler</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createObservable().</span><br><span class="line">	.doSomething()</span><br><span class="line">	.subscribeOn(scheduler1) <span class="comment">// (1)</span></span><br><span class="line">	.doSomethingElse()</span><br><span class="line">	.observeOn(scheduler2) <span class="comment">// (2)</span></span><br><span class="line">	.doAnother()</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>如上代码，在(1)处执行了<code>subscribeOn</code>之后，之前的操作createObservable()和doSomething()都会在scheduler1中执行，随后的doSomethingElse()同样也在scheduler1中执行，随后用<code>observeOn</code>指定了另外一个scheduler2，之后的doAnother()会在scheduler2上执行。</p>
<h2 id="为原有代码添加Rx扩展"><a href="#为原有代码添加Rx扩展" class="headerlink" title="为原有代码添加Rx扩展"></a>为原有代码添加Rx扩展</h2><p>RxSwift中提供了一种扩展机制，可以很方便的为原有的代码添加上Rx扩展。首先来看一个结构体<code>Reactive</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/// base是扩展的对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Reactive</code>是一个泛型结构体，只定义了一个属性<code>base</code>，并且在初始化结构体的时候传入该属性的值。</p>
<p>此外还定义了一个协议<code>ReactiveCompatible</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ReactiveCompatible</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">CompatibleType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">CompatibleType</span>&gt;.<span class="type">Type</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">CompatibleType</span>&gt; &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该协议中分别为类对象和实例对象定义一个名字相同的属性：<code>rx</code>，类型为上面定义的<code>Reactive</code>，随后通过协议扩展为其提供了<code>get</code>的默认的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReactiveCompatible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt;.<span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt;.<span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// this enables using Reactive to "mutate" base type</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Reactive</span>(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// this enables using Reactive to "mutate" base object</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关联类型<code>CompatibleType</code>被自动推导为实现该协议的类本身，使用<code>self</code>初始化一个<code>Reactive</code>对象。</p>
<p>最后通过协议扩展为所有的NSObject类型实现了<code>ReactiveCompatible</code>协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span>: <span class="title">ReactiveCompatible</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，代码中所有继承自NSObject的类型实例中都会有一个类型为<code>Reactive</code>的属性<code>rx</code>，当我们要为自己的类型添加Rx扩展时，只需要通过扩展向<code>Reactive</code>中添加方法就可以了，例如向UIButton类型添加扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIButton</span> </span>&#123; <span class="comment">// 为Reactive&lt;UIButton&gt;添加扩展</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> tap: <span class="type">ControlEvent</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> controlEvent(.touchUpInside) <span class="comment">// 通过base可以访问该实例本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Reactive</code>是一个泛型类型，我们可以通过where语句指定泛型的类型，这样一来，我们就可以在UIButton实例的rx中访问tap属性了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>(...)</span><br><span class="line">button.rx.tap</span><br></pre></td></tr></table></figure>
<p>类似RxCocoa这样的RxSwift扩展库都是通过这种方式进行Rx扩展的。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/13/在iOS项目中自动生成函数调用关系图/" rel="next" title="在iOS项目中自动生成函数调用关系图">
                <i class="fa fa-chevron-left"></i> 在iOS项目中自动生成函数调用关系图
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/13/drafter/" rel="prev" title="Drafter - 一个在iOS项目中分析代码结构的工具">
                Drafter - 一个在iOS项目中分析代码结构的工具 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Observable"><span class="nav-number">1.</span> <span class="nav-text"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Observer"><span class="nav-number">2.</span> <span class="nav-text"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Dispose"><span class="nav-number">3.</span> <span class="nav-text"><a href="#Dispose" class="headerlink" title="Dispose"></a>Dispose</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建序列"><span class="nav-number">4.</span> <span class="nav-text"><a href="#&#x521B;&#x5EFA;&#x5E8F;&#x5217;" class="headerlink" title="&#x521B;&#x5EFA;&#x5E8F;&#x5217;"></a>&#x521B;&#x5EFA;&#x5E8F;&#x5217;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Share"><span class="nav-number">5.</span> <span class="nav-text"><a href="#Share" class="headerlink" title="Share"></a>Share</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列的变换和组合"><span class="nav-number">6.</span> <span class="nav-text"><a href="#&#x5E8F;&#x5217;&#x7684;&#x53D8;&#x6362;&#x548C;&#x7EC4;&#x5408;" class="headerlink" title="&#x5E8F;&#x5217;&#x7684;&#x53D8;&#x6362;&#x548C;&#x7EC4;&#x5408;"></a>&#x5E8F;&#x5217;&#x7684;&#x53D8;&#x6362;&#x548C;&#x7EC4;&#x5408;</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#变换"><span class="nav-number">6.1.</span> <span class="nav-text"><a href="#&#x53D8;&#x6362;" class="headerlink" title="&#x53D8;&#x6362;"></a>&#x53D8;&#x6362;</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#组合"><span class="nav-number">6.2.</span> <span class="nav-text"><a href="#&#x7EC4;&#x5408;" class="headerlink" title="&#x7EC4;&#x5408;"></a>&#x7EC4;&#x5408;</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Subject"><span class="nav-number">7.</span> <span class="nav-text"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scheduler"><span class="nav-number">8.</span> <span class="nav-text"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#subscribeOn和observeOn"><span class="nav-number">8.1.</span> <span class="nav-text"><a href="#subscribeOn&#x548C;observeOn" class="headerlink" title="subscribeOn&#x548C;observeOn"></a>subscribeOn&#x548C;observeOn</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为原有代码添加Rx扩展"><span class="nav-number">9.</span> <span class="nav-text"><a href="#&#x4E3A;&#x539F;&#x6709;&#x4EE3;&#x7801;&#x6DFB;&#x52A0;Rx&#x6269;&#x5C55;" class="headerlink" title="&#x4E3A;&#x539F;&#x6709;&#x4EE3;&#x7801;&#x6DFB;&#x52A0;Rx&#x6269;&#x5C55;"></a>&#x4E3A;&#x539F;&#x6709;&#x4EE3;&#x7801;&#x6DFB;&#x52A0;Rx&#x6269;&#x5C55;</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
