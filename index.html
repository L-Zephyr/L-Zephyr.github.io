<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/19/Unicode的前世今生/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/19/Unicode的前世今生/" itemprop="url">Unicode的前世今生</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-19T20:34:13+08:00">
                2017-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前突然发现自己对字符编码还是一知半解，基本上只是听说过各种编码的名字，对它们之间的特点和区别还是不甚了解。所以这段时间查阅了许多资料，对字符编码也大概有了一些整体的了解，写下这篇文章作为总结。</p>
<h1 id="在Unicode之前"><a href="#在Unicode之前" class="headerlink" title="在Unicode之前"></a>在Unicode之前</h1><p>为了在计算机的中储存人类可以阅读的文本，必须按照一定的规范将字符映射为计算机可以储存的数值，在计算机发展的早期渐渐形成了统一的标准，在1967年ASCII编码首次作为规范标准发布。这是一套用来表示现代英文的编码约定，全称为<em>美国信息交换标准代码</em>。ASCII编码非常简单，只定义了128个字符，每个字符通过唯一的编号来表示，每个字符占用一个字节（8bit）的空间，因为只有128个字符（2的7次方），所以每个字符的第一位始终为0。</p>
<p>一个ASCII字符只有8位，最多只能表示256个字符，对于英文来说足够了，但是对于像中文这样的语言而言是远远不足的。所以在ASCII之上做了一些扩展，用两个字节来表示一个字符，这就是1981年发布的<strong>GB2312编码</strong>，为了与ASCII作区分，GB2312中每个字节的最高位都是1。这一套编码中包含了6000多个常用的简体汉字，基本满足日常使用的需求。但是不支持繁体汉字和一些生僻字，所以在后来又在GB2312上进行了扩展，这就是之后的<strong>GBK编码</strong>，全称为<em>汉字内码扩展规范</em>。</p>
<p>事实上在那个年代还有很多不同的汉字编码百花齐放，而且不止是中文，世界上其他各种语言都在指定自己的标准，不同编码之间无法相互兼容，这为互联网的推广带来了很大的麻烦，统一字符编码势在必行。</p>
<h1 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h1><p>Unicode是国际标准化组织制定的一套字符编码方案，致力于统一世界上所有语言字符的编码。Unicode为每个字符分配了一个固定的数值，称为<strong>编码点</strong>（Code Point），所有的编码点组成的集合称为<strong>编码空间</strong>（Code Space）。目前Unicode的编码空间共包含<code>0x10FFFF</code>（十进制的1114111）个编码点，被划分为17个平面，每个平面包含<code>0xFFFF</code>个字符。从1991年发布的第一个版本开始，每一年都会有新的字符被编入Unicode中，目前所定义的字符集只用了不到五分之一的编码空间。</p>
<h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><p>Unicode制定了一套字符集编码的标准，而在实际中如何去表示一个编码点呢，有几种不同编码方案：UTF-8、UTF-16和UTF-32，这几种方案各有特点。</p>
<h3 id="UTF-32："><a href="#UTF-32：" class="headerlink" title="UTF-32："></a>UTF-32：</h3><p>这是最简单的一种编码方式，定长编码。使用4个字节作为一个编码单元，也就是说每一个编码点都用4个字节来表示。</p>
<p>定长编码的一个好处就是每个字符的做占用的空间都是相同的，所以当我们想要获取第n个位置的字符时，直接在首字符的地址加上一个固定的偏移量就可以了，也就是说可以在O(1)的时间复杂度索引字符串的任意位置，这也是我们常说的<strong>随机索引</strong>。但是这样做的缺点也十分明显，每个字符占用32个bit，肯定会造成大量的空间浪费，出于这个原因UTF-32编码用得并不多。</p>
<h3 id="UTF-16："><a href="#UTF-16：" class="headerlink" title="UTF-16："></a>UTF-16：</h3><p>在介绍UTF-16之前，先讲讲<strong>UCS-2</strong>编码。在早期的Unicode标准中，只定义了不到65535（0xFFFF，2的16次方）个编码点，所有的字符都可以用两个字节的UTF-16编码来表示，所以在那个时候UTF-16还是一个定长编码，UCS-2就等同于UTF-16。然而设计师还是错误的估算了编码点的范围，16位的范围并不足以囊括世界上的所有文字，所以Unicode需要扩大最初的范围。在新的标准中编码空间被扩展到了<code>0x10FFFF</code>的大小，分成17块65535大小的板块，第一个板块包含了最初UCS-2中定义的65535个编码点，被称为<strong>基本多文种平面</strong>（BMP），余下新增的16个板块称为<strong>辅助平面</strong>。所以在今天来说，UTF-16可以看成UCS-2的父集。</p>
<p>随着标准的扩充，UTF-16也必须扩展以支持更多的编码点。在如今的UTF-16编码中使用了2个字节作为一个编码单元，一个编码点需要2个或4个字节来表示。</p>
<p>为了能正确表示辅助平面中的编码点，UTF-16对编码点的前缀做了一些约束，引入了一个称为<code>代理编码点</code>（surrogate）的概念。也就是在Unicode的编码空间中划分出了一块保留区域，落在在这个区域中的编码点就是代理编码点，这块区域包含从前缀<code>110110</code>到前缀<code>110111</code>的所有编码点，也就是从<code>1101100000000000</code>到<code>1101111111111111</code>的范围，十六进制为<code>0xD800</code>到<code>0xDFFF</code>。这个区域中的编码点只能成对出现在UTF-16编码中，出现在UTF-32和UTF-8中都是非法的。</p>
<p>UTF-16在编码的时候遵循以下规则：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字节数</th>
<th style="text-align:center">UTF-16二进制表示</th>
<th style="text-align:center">编码点</th>
<th style="text-align:center">编码范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">xxxxxxxxyyyyyyyy</td>
<td style="text-align:center">xxxxxxxxxxxxxxxx</td>
<td style="text-align:center">0 ~ 0xFFFF</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">110110xxxxxxxxxx + 110111yyyyyyyyyy</td>
<td style="text-align:center">xxxxxxxxxxyyyyyyyyyy + 0x10000</td>
<td style="text-align:center">0x10000 ~ 0x10FFFF</td>
</tr>
</tbody>
</table>
<p>当编码点在0到0xFFFF的范围内时，这两个字节中的所有bit都可用来表示编码点；而当编码点大于0xFFFF，就必须要使用两个代理编码点了，分别取前后两个字节中低位的10个bit，这样就有了20bit的编码空间，最大能表示0x100000的值，再加上0xFFFF，正好就是<code>0x10FFFF</code>，Unicode中定义的最大编码空间。</p>
<h3 id="UTF-8："><a href="#UTF-8：" class="headerlink" title="UTF-8："></a>UTF-8：</h3><p>UTF-8使用单个字节作为编码单元，这是一种变长编码，根据需要使用1个到4个字节来表示一个编码点。在这种编码模式中，一个字节可能是表示一个单字节的字符，也可能是多字节字符中的一部分，在解析的时候必须要能够区分出来。所以在UTF-8中每个字节最高的几个bit不用来储存编码值，而是用来表示该字节在其所表示的字符中的位置：</p>
<table>
<thead>
<tr>
<th style="text-align:center">字节数</th>
<th style="text-align:center">UTF-8二进制表示</th>
<th style="text-align:center">编码点</th>
<th style="text-align:center">编码范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0xxxxxxx</td>
<td style="text-align:center">xxxxxxx (7bit)</td>
<td style="text-align:center">0 ~ 0x7F</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">110xxxxx + 10yyyyyy</td>
<td style="text-align:center">yyyyyzzzzzz (11bit)</td>
<td style="text-align:center">0x80 ~ 0x7FF</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">1110xxxx + 10yyyyyy + 10zzzzzz</td>
<td style="text-align:center">xxxxyyyyyyzzzzzz (16bit)</td>
<td style="text-align:center">0x800 ~ 0xD7FF + 0xE000 ~ 0xFFFF</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">11110xxx + 10yyyyyy + 10zzzzzz + 10wwwwww</td>
<td style="text-align:center">xxxyyyyyyzzzzzzwwwwww (21bit)</td>
<td style="text-align:center">0x10000 ~ 0x10FFFF</td>
</tr>
</tbody>
</table>
<p><em>3个字节的情况下有两个编码范围，这是因为上一节中提到的代理编码点不能表示任何字符</em></p>
<p>简单来说UTF-8的编码规则只有两条：</p>
<ol>
<li>单字节字符的最高位为0，后7位为该字符的编码值。</li>
<li>n个字节的符号(n &gt; 1)，第一个字节的最高n位都为1，n + 1位为0，剩余的字节的最高位都为10。</li>
</ol>
<p>可以看到，单字节的UTF-8编码最高位作为标志位始终为0，在上面提到的ASCII编码中最高位没有用上也始终为0。也就是说前128个字符的编码方式与ASCII是完全相同的，这样一来UTF-8就能够完全兼容ASCII，用ASCII编码的文件无需任何转换就可以直接被UTF-8所识别。</p>
<p>对空间的高效利用，以及对ASCII兼容性，使得UTF-8成为了最主流的编码方式。</p>
<h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>说到字节序的问题必须先谈一谈大端和小端，在计算机的世界中多字节的数据会按照其字节顺序被储存，而字节之间的排列方式有两种：<strong>大端模式</strong>（Big-Endian）和<strong>小端模式</strong>（Big-Endian）：</p>
<ul>
<li><strong>大端模式</strong>：低位字节排放在内存中的高位地址，高位字节排放在内存中的低位地址。</li>
<li><strong>小端模式</strong>：低位字节排放在内存中的低位地址，高位字节排放在内存中的高位地址。</li>
</ul>
<p>比如说有一个<code>short</code>类型的数据<code>0x3A80</code>，需要占用2个字节的空间，其中高位字节为<code>3A</code>，低位字节为<code>80</code>。</p>
<p>使用<strong>大端模式</strong>储存时内存的排列方式如下，内存中的高地址方向存放的是低位字节<code>80</code>：</p>
<p><img src="/images/big-endian.png" alt="大端模式"></p>
<p>使用<strong>小端模式</strong>存储时内存中的排列方式如下，内存中高地址方向存放的是高位字节<code>3A</code>：</p>
<p><img src="/images/little-endian.png" alt="小端模式"></p>
<p>再回到Unicode中，由于UTF-16使用了两个字节作为一个编码单元，在解析的时候每次需要读取两个字节，所以字节序就变得尤为重要。例如汉字<code>呀</code>的编码点为<code>0x5440</code>，如果以错误的字节序来读取的话，则会将其识别为<code>0x4054</code>，这样一来就变成了汉字<code>䁔</code>。</p>
<p>为了保证字符串始终能以正确的字节序来读取，标准建议UTF-16文件在起始的位置加上<code>0xFEFF</code>，称为<code>字节顺序标记（BOM）</code>。因为在读取文件是按照低地址到高地址的顺序，所以如果读取到<code>0xFEFF</code>则说明该文件是采用大端模式来储存的；如果读取到<code>0xFFFE</code>则说明文件是采用小端模式来存储的。</p>
<p>如果使用的是UTF-8编码则不需要关心这个问题，因为UTF-8的编码单元只有一个字节，每次只需要读取一个字节即可，所以不存在字节顺序的问题。</p>
<h2 id="组合字符"><a href="#组合字符" class="headerlink" title="组合字符"></a>组合字符</h2><p>Unicode的复杂性不仅体现在其编码方式上，在Unicode中有一些字符存在多种不同的表示方式。这是什么意思呢？有一些文字会带有音调符号，比如一个带有音标的符号<code>ǎ</code>，它可以直接通过编码点<code>0x01CE</code>来表示，也可以使用一个<code>a</code>（编码点为<code>0x0061</code>）和一个<code>̌</code>（编码点为<code>0x030C</code>）组合起来表示，虽然说编码看起来不一样，但是这两种写法在语义上和视觉上都是相同的。这样就引入了一个新的概念，我们称<code>ǎ</code>字符和<code>a</code>、<code>̌</code>组成的序列是<strong>标准等价</strong>的。</p>
<p>这样麻烦就来了，当用两种写法来表示同一个字符的时候，计算机根据字节比较会认为它们是不同的。为了能正确判断字符串之间的等价性，Unicode规定了一套标准的<strong>正规化</strong>算法（有四种正规化的形式，就不再展开介绍了），也就是将所有标准等价的字符转换成统一的表示形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="string">'\u&#123;01CE&#125;'</span>; <span class="comment">// ǎ</span></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="string">'\u&#123;0061&#125;\u&#123;030C&#125;'</span>; <span class="comment">// ǎ</span></span><br><span class="line"></span><br><span class="line">c1.normalize(); <span class="comment">// 01CE</span></span><br><span class="line">c1.normalize(); <span class="comment">// 01CE</span></span><br></pre></td></tr></table></figure>
<p>在上面的这一段JavaScript代码中，<code>ǎ</code>的两种写法在经过正规化之后都被转换成了相同编码<code>01CE</code>，这样一来就能正确的进行相等性比较了。</p>
<p>到了Emoji这边情况就变得更加复杂了，很多Emoji表情是用多个Unicode码点来表示的，比如说❤️是由一个心型字符 ❤（0x2764）和一个样式控制符号（0xFE0F）组合而成。此外Emoji还支持使用<strong>零宽度连接符</strong>（ZWJ，码点为<code>0x200D</code>）将多个Emoji字符组合新的字符。也就是将<code>0x200D</code>字符放在两个Emoji字符的中间，这两个Emoji会被连接起来组成新的Emoji字符。比如说👩和👦可以组合成👩‍👦（<code>\u{1f469}\u{200d}\u{1f466}</code>），像👨‍👩‍👧‍👧这种Emoji更是由7个Unicode字符组合成的复杂字符。</p>
<p>从上面的这些例子中可以看出，在Unicode中语义上的单个字符实际上可能是由许多个字符组合而成的，为了更好的描述这种场景，Unicode中引入了一个称为<strong>字位簇</strong>（grapheme cluster）的概念。字位簇用来表示一个语义上的字符，不论是单个字符还是包含多个字符序列的组合字符，都视为一个字位簇。</p>
<h1 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h1><p>在了解了Unicode的各种特性之后再来看看不同语言中对于字符编码的处理吧，下面对比了一下个人平常使用的语言中字符编码的异同：</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>在JavaScript刚刚发布的那个年代，还是UCS-2的天下，所以JavaScript内部字符串的编码方式采用了UTF-16，准确的说是UTF-16的子集UCS-2。</p>
<p>这一历史问题为今天的JavaScript带来了一些困扰，因为所有的字符在JavaScript中都被视为两个字节的编码，如果字符串中包含辅助平面的编码点时，JavaScript会将其视为2个2字节的字符来处理。这个问题影响了JavaScript中的字符处理函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="string">'𠀗'</span>; <span class="comment">// 0x20017</span></span><br><span class="line">c.length; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">c.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>); <span class="comment">// 0xD840</span></span><br><span class="line">c.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>); <span class="comment">// 0xDC17</span></span><br></pre></td></tr></table></figure>
<p>上面代码中汉字”𠀗”的Unicode编码点是<code>0x20017</code>，大小超过了<code>0xFFFF</code>，位于辅助平面中，所以在UTF-16中需要4个字节，编码为<code>0xD840DC17</code>。调用length的输出是2，说明JavaScript将其识别成了两个字符。<code>charCodeAt</code>是一个用来打印指定位置字符编码值的方法，将结果转换成16进制后可以看到分别输出了两个编码单元的值<code>d840</code>和<code>dc17</code>。想必前端的同学一定对这些多字节字符处理上的坑深恶痛绝。</p>
<p>不过好消息是ES6以来这些坑也在陆续填上了：新增的<code>codePointAt</code>方法能正确识别4字节的UTF-16字符、新的Unicode字符表示方法<code>\u{20017}</code>、新增<code>for…of</code>循环也能正确的遍历4字节字符…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="string">'𠀗'</span>;</span><br><span class="line"><span class="built_in">Array</span>.from(c).length; <span class="comment">// 1</span></span><br><span class="line">c.codePointAt(<span class="number">0</span>) <span class="comment">// 20017</span></span><br></pre></td></tr></table></figure>
<h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><p>OC中对字符串的处理与JavaScript类似，内部的字符串编码同样采用了UCS-2，上面的那个例子在OC中会获得同样的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *s = @&quot;𠀗&quot;; // 0x20017</span><br><span class="line">s.length; // 2</span><br><span class="line">[s characterAtIndex:0]; // 0xD840</span><br><span class="line">[s characterAtIndex:1]; // 0xDC17</span><br></pre></td></tr></table></figure>
<p>想要获得正确的字符数可以先将字符串转换成定长的UTF-32编码，然后再除以4：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[@&quot;𠀗&quot; lengthOfBytesUsingEncoding:NSUTF32StringEncoding] / 4; // 1</span><br></pre></td></tr></table></figure>
<p>这样子可以正确的识别出Unicode码点的个数，然而对于组合字符还是无能为力。</p>
<p>这个问题同样会影响到比较字符串时常用的<code>isEqualToString</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSString *s1 = @&quot;a\u030C&quot;; // ǎ</span><br><span class="line">NSString *s2 = @&quot;\u01CE&quot;; // ǎ</span><br><span class="line"></span><br><span class="line">[s1 isEqualToString:s2]; // NO</span><br></pre></td></tr></table></figure>
<p>若要对字符串进行标准等价比较，必须使用<code>compare</code>方法，或者先使用<code>precomposedStringWithCanonicalMapping</code>方法将字符串正规化：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[s1 compare:s2] == NSOrderedSame; // YES</span><br><span class="line">[s1 precomposedStringWithCanonicalMapping];</span><br></pre></td></tr></table></figure>
<h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>Swift在字符串编码上做了很多事情，Swift用<code>String</code>类型来表示字符串，不同的是在遍历字符串的时候有很多种选择，可以按照字符来遍历，也可以按照UTF-8或UTF-16编码来遍历：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"\u&#123;0061&#125;\u&#123;030C&#125;"</span> <span class="comment">// ǎ</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> <span class="built_in">c</span> <span class="keyword">in</span> s &#123;...&#125; <span class="comment">// ǎ</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> <span class="built_in">c</span> <span class="keyword">in</span> s.utf8 &#123;...&#125; <span class="comment">// 0x61、0xCC、0x8C</span></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">var</span> <span class="built_in">c</span> <span class="keyword">in</span> s.utf16 &#123;...&#125; <span class="comment">// 0x0061、0x030C</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中s是直接以Unicode标量来初始化的，而<code>s.utf8</code>会将其转换成UTF-8的编码方式，随后遍历每一个<strong>编码单元</strong>，UTF-16也与之类似。字符串对象中utf8和utf16这两个属性的类型分别是<code>String.UTF8View</code>和<code>String.UTF16View</code>，它们都是一个集合类型，实现了<code>BidirectionalCollection</code>协议，之所以没实现<code>RandomAccessCollection</code>是因为UTF-8和UTF-16都是变长编码，没办法做到随机索引。</p>
<p><code>String</code>类型重载了<code>==</code>符号，而且在比较的时候会自动将字符串正规化后再进行比较：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">"\u&#123;0061&#125;\u&#123;030C&#125;"</span> <span class="comment">// ǎ</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="string">"\u&#123;01CE&#125;"</span> <span class="comment">// ǎ</span></span><br><span class="line"></span><br><span class="line">s1 == s2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>在这一点上</p>
<h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>一个字符串是多个字符组成的序列，Swift中表示单个字符的类型是<code>Character</code>。Character表示的是一个Unicode的<strong>字位簇</strong>，也就是说一个Character中可以包含多个Unicode编码点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"👨‍👩‍👧‍👧abc"</span></span><br><span class="line">s.first <span class="comment">// 👨‍👩‍👧‍👧</span></span><br></pre></td></tr></table></figure>
<p>可以看到像上面这种带组合字符的情况在Character中能够被正确的处理，<code>s.first</code>获取到的第一个字符是👨‍👩‍👧‍👧（而不是👨）。</p>
<p>Character中提供了<code>unicodeScalars</code>属性用来访问字位簇中的每一个Unicode编码点，每个编码点通过<code>Unicode.Scalar</code>类型来表示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="string">"👨‍👩‍👧‍👧"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">c</span>.unicodeScalars.<span class="built_in">count</span> <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">c</span>.unicodeScalars.first?.value <span class="comment">// 0x1F468 (Unicode编码点)</span></span><br><span class="line"><span class="built_in">c</span>.unicodeScalars.first?.utf16 <span class="comment">// 0xD83D、0xDC68</span></span><br></pre></td></tr></table></figure>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://blog.csdn.net/zhuxipan1990/article/details/51602299" target="_blank" rel="noopener">http://blog.csdn.net/zhuxipan1990/article/details/51602299</a></p>
<p><a href="http://blog.jobbole.com/111261/" target="_blank" rel="noopener">http://blog.jobbole.com/111261/</a></p>
<p><a href="https://zh.wikipedia.org/wiki/UTF-16" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/UTF-16</a></p>
<p><a href="https://zh.wikipedia.org/wiki/UTF-8" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/UTF-8</a></p>
<p><a href="https://objccn.io/issue-9-1/" target="_blank" rel="noopener">https://objccn.io/issue-9-1/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/13/drafter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/13/drafter/" itemprop="url">Drafter - 一个在iOS项目中分析代码结构的工具</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-13T18:45:13+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在很久之前的一篇<a href="http://www.jianshu.com/p/e19aafbaddca" target="_blank" rel="noopener">博客</a>中，曾经用clang提供的库<code>LibTooling</code>编写了一个简单的导出iOS代码中函数调用关系图的工具，然而这种实现方式存在一些很明显的缺点：</p>
<ol>
<li>在分析一个工程中的单个代码文件时，无法得知定义在其他文件中的类或方法，导致生成的语法树节点缺失，对最终的结果造成不小的影响。</li>
<li>在解析时clang会进行预处理，导致最终生成的结果可能包括一些外部系统库的函数，这对于我们来说是无用的信息（当然这个应该是我的使用姿势问题）。</li>
<li>无法支持swift。swift编译器的前端并不是clang，而这个工具是基于clang的库来开发的，所以也就没有支持swift的可能。</li>
</ol>
<p>由于这几个缺点（主要是第三点，因为在日常工作中还是以swift为主），后来也没有再继续使用和完善。直到最近因为工作上的安排，需要维护一份较为陈旧的代码，面对动辄数千行的代码文件，觉得还是需要一个比较趁手的工具来辅助阅读。前段时间正好恰逢国庆长假，抽空用swift重新写了一个工具：drafter，如名字所示，它的目的在于生成描述代码的草图。</p>
<h2 id="Drafter是什么"><a href="#Drafter是什么" class="headerlink" title="Drafter是什么"></a>Drafter是什么</h2><ul>
<li>Drafter是一个命令行工具，用于分析iOS工程的代码，支持Objective-C和Swift。</li>
<li>自动解析代码并生成方法调用关系图。</li>
<li>自动解析代码并生成类继承关系图。</li>
</ul>
<h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><p>完整的代码在这里：<a href="https://github.com/L-Zephyr/Drafter" target="_blank" rel="noopener">https://github.com/L-Zephyr/Drafter</a></p>
<p>这里提供了一个快速安装的脚本，在shell中执行指令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl "https://raw.githubusercontent.com/L-Zephyr/Drafter/master/install.sh" | /bin/sh</span><br></pre></td></tr></table></figure>
<p><code>drafter</code>程序会自动安装到  /usr/local/bin 目录中，之后直接在终端使用即可。</p>
<p>具体使用方法请查看<a href="https://github.com/L-Zephyr/Drafter#基本使用" target="_blank" rel="noopener">使用介绍</a></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p><em>注：解析器部分后来已用parser combinator重构，文章所讲述的代码对应于0.1.0的tag</em></p>
<p>在之前的做法中对源码的解析全交给clang，只对生成的AST做处理，这其实是一种比较偷懒的做法，对最后生成的结果不可控，而且也断了支持swift的可能。为了获得更优化的输出并同时支持Swift和OC，源码解析这一步还是得自己来做。幸运的是我们只需要解析类、方法定义、方法调用这几块，实际工作并不是很复杂。</p>
<h3 id="词法解析"><a href="#词法解析" class="headerlink" title="词法解析"></a>词法解析</h3><p>词法解析是程序编译的第一步，所谓词法解析就是将代码分割成一系列的词法单元。词法单元是一个有特殊意义的标记，也是语法分析程序在处理源代码时的最小单元。比如说一个简单的赋值表达式<code>int i = 3</code>，在经过词法分析之后被处理成了一系列的词法单元：<code>int</code>、<code>i</code>、<code>=</code>、<code>3</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Token</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> type: <span class="type">TokenType</span></span><br><span class="line">    <span class="keyword">var</span> text: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TokenType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> endOfFile   <span class="comment">// 文件结束</span></span><br><span class="line">    <span class="keyword">case</span> name        <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">case</span> colon       <span class="comment">// 冒号 	</span></span><br><span class="line">    <span class="keyword">case</span> comma       <span class="comment">// 逗号     </span></span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先定义一个名为<code>Token</code>的结构体，用来表示词法单元，其中枚举值<code>type</code>用来表示词法单元的类型，<code>text</code>保存该词法单元的原始数据，如：对于一个变量n，它在解析成Token之后type为<code>.name</code>，text为<code>n</code>。由于我们的目的只是解析类和方法，所以这里只定义了在类和方法的定义中会用到的词法单元类型，对于那些我们不关心的词法则一概忽略。</p>
<p>词法解析器会将任何输入的源代码解析成词法单元流，对于上层使用者来说就像是迭代器一样遍历词法单元直到文件结束，所以这里可以定义一个基本的词法解析器类型，只有一个计算属性<code>nextToken</code>，用来获取下一个词法单元：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Lexer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nextToken: <span class="type">Token</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h3><p>在经过第一步的词法分析将源代码分割成带有类型的词法单元之后，就可以进入语法解析的阶段了。要分析一段程序，如表达式<code>1 + 2</code>，我们是无法直接从字面上来处理的，必须将其转换成某种可以处理的中间形式，这就是语法解析要做的事情。语法解析器根据语言的文法规则扫描词法单元流，同时生成中间表示形式（IR），通常来说会生成一棵抽象语法树（AST），之后的语义分析阶段会基于这一步生成的AST进行分析。Drafter只处理到语法解析这一步，仅对代码中的类、方法定义和方法调用进行解析，解析后生成的数据结构也比较简单。</p>
<h4 id="语言的文法描述"><a href="#语言的文法描述" class="headerlink" title="语言的文法描述"></a>语言的文法描述</h4><p>程序是由多个有效的表达式组成的，我们要做的就是将这些符合特定规则的式子识别出来，语言特定的语法规则称为这门语言的文法，这种规则可以用一种DSL来描述（BNF范式）。</p>
<p>举个例子（来源于《编程语言实现模式》一书），对于一个可以包含任意字母的列表声明如<code>[a, b, c]</code>，它的文法规则描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = <span class="string">'['</span> elements <span class="string">']'</span>; <span class="comment">// 单引号之间的内容直接匹配</span></span><br><span class="line">elements = elemenet (<span class="string">','</span> element)*; <span class="comment">// *表示0个或多个</span></span><br><span class="line">element = NAME | <span class="built_in">list</span>; <span class="comment">// |表示或，元素可能是另一个列表</span></span><br><span class="line">NAME = (<span class="string">'a'</span>.<span class="number">.'</span>z' | <span class="string">'A'</span>.<span class="number">.'</span>Z')+; <span class="comment">// +表示一个或多个</span></span><br></pre></td></tr></table></figure>
<p>上面每一条式子都描述了一条文法规则，这里将词法规则和文法规则做了区分，文法规则的名称小写，词法规则的名称大写。像<code>list</code>这样的规则称为产生式，它可以继续向下推导，如<code>list</code>会产生<code>elements</code>。另外有一些被单引号包围的符号，这样的符号是实际要匹配的内容，称为终结符，因为它无法再继续往下推导了。</p>
<p>这个文法描述了一个列表声明的语法，每个规则都包含一个或多个解析选项，多个解析选项通过<code>|</code>符号分隔。上面声明了三个文法规则和一个词法规则：词法规则<code>NAME</code>匹配包含至少一个字母的词法单元；<code>list</code>规则表示列表必须由中括号包围，并至少包含一个元素，多个元素之间用逗号分隔，元素可以是一个变量也可以是另一个列表声明。</p>
<p>有了明确的文法规则定义我们才能够去编写语法解析器，对Objective-C的文法我参考了<a href="https://kornel.ski/objective-c-grammar" target="_blank" rel="noopener">这里</a>。</p>
<h4 id="递归下降分析法"><a href="#递归下降分析法" class="headerlink" title="递归下降分析法"></a>递归下降分析法</h4><p>定义了语法的结构和相关的词法单元之后，在解析时只需要识别出相应的式子即可，简单来说解析器的工作就是：遇到某种结构，就执行某种操作。具体到实现上，我们为每一种文法规则提供一个专用匹配函数，对于词法规则则统一用<code>match</code>函数来匹配：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@discardableResult</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">match</span><span class="params">(<span class="number">_</span> t: TokenType)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Token</span> <span class="comment">// 匹配指定类型词法单元，匹配成功返回该词法单元</span></span><br></pre></td></tr></table></figure>
<p>对于上面那个列表的例子，可以编写如下用于识别的函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">list</span><span class="params">()</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">elements</span><span class="params">()</span></span> <span class="keyword">throws</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">element</span><span class="params">()</span></span> <span class="keyword">throws</span></span><br></pre></td></tr></table></figure>
<p>每个函数都识别一个特定的子结构，并且可能会调用其他的识别函数或递归调用自身。在识别时从起始的词法单元开始，自上而下进行推导。所以这种分析的方法也被称为递归下降分析法，以这种方法编写的解析器称为LL解析器。第一个L表示解析内容的输入顺序是从左到右，第二个L表示解析时也是从左向右进行推导（最左推导）。</p>
<p>对于上面的<code>element</code>规则，它可能匹配一个变量名或是另一个列表，在进入<code>element</code>函数时需要先进行判断，所幸<code>list</code>规则始终以<code>[</code>符号开始，变量的规则始终以字母开始，只需要检查当前的词法单元类型就可以做出判断：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">element</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> currentToken.type == .leftSquare &#123;</span><br><span class="line">      	<span class="keyword">try</span> list()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> match(.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个列表的文法规则中，从当前的位置开始只需要检查一个词法单元的类型就可以做出决断，像这样的文法称为<code>LL(1)</code>文法，相应的解析器称为LL(1)解析器，1表示该解析器只能从解析位置向前查看一个词法单元，通常这个词法单元被称为前瞻符号（lookahead）。</p>
<h4 id="LL-k-解析器"><a href="#LL-k-解析器" class="headerlink" title="LL(k)解析器"></a>LL(k)解析器</h4><p>LL(1)解析器十分简单，但是解析能力不足。比如在上面列表语法的例子中，为列表的元素添加一个赋值的操作：<code>[a, b = c, d]</code>，这样一来，<code>element</code>规则就变成了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element = NAME</span><br><span class="line">		| NAME <span class="string">'='</span> NAME</span><br><span class="line">		| <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<p><code>element</code>文法中有两个解析选项都是以词法单元<code>NAME</code>开头的，仅查看一个词法单元无法确定，在解析时需要向前检查更多的词法单元，也就是说这个语法不再是LL(1)的了。</p>
<p>在实际解析时情况比这里要复杂很多，可能需要向前检查看多个词法单元才能确定解析策略，所以需要构建一个能够根据需要查看任意多符号的解析器，也就是LL(k)解析器。目前在应用上有一些能够根据特定DSL自动生成解析器的工具，如Antlr等，但是考虑通过DSL生成的代码并不是特别便于调试，而且Drafter只是做了一些非常简单的解析工作，所以还是自己编写了一个简单的LL(k)解析器。在Drafter中提供一个这样一个基础的解析器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BacktrackParser</span>: <span class="title">Parser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">init</span>(lexer: <span class="type">Lexer</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.input = lexer</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">func</span> <span class="title">token</span><span class="params">(at index: Int = <span class="number">0</span>)</span></span> -&gt; <span class="type">Token</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">  	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以一个词法解析器(Lexer)作为初始化参数，<code>token()</code>方法提供从当前位置开始向前查看任意位置词法单元的能力，而具体的文法规则解析则通过各个子类化的解析器来完成。Objective-C和Swift的代码通过不同的解析器来进行，解析完成后输出相同的数据结构，如表示类型的节点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassNode</span>: <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> superCls: <span class="type">ClassNode</span>? = <span class="literal">nil</span> <span class="comment">// 父类</span></span><br><span class="line">    <span class="keyword">var</span> className: <span class="type">String</span> = <span class="string">""</span>     <span class="comment">// 类名</span></span><br><span class="line">    <span class="keyword">var</span> protocols: [<span class="type">String</span>] = []   <span class="comment">// 实现的协议</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在将所有关心的语法节点信息解析出来之后，剩下的就是对这些信息进行处理和展示了。Drafter中提供了一些对语法节点进行过滤和搜索的选项，通过提供的参数过滤出感兴趣的信息，最后将这些数据传递给<code>DotGenerator</code>类，这个类的作用是根据节点信息生成<code>Dot</code>语言（一种描述图形的语言）的代码，传递给<a href="http://www.graphviz.org/Download_macos.php" target="_blank" rel="noopener">Graphviz</a>生成图片。</p>
<h4 id="方法调用解析"><a href="#方法调用解析" class="headerlink" title="方法调用解析"></a>方法调用解析</h4><p>单独讨论一下对于方法调用的解析，首先为方法调用定义一个语法节点类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MethodInvoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> name(<span class="type">String</span>)    <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="keyword">case</span> method(<span class="type">MethodInvokeNode</span>) <span class="comment">// 另一个方法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodInvokeNode</span>: <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> isSwift: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">var</span> invoker: <span class="type">MethodInvoker</span> = .name(<span class="string">""</span>) <span class="comment">// 调用者</span></span><br><span class="line">    <span class="keyword">var</span> params: [<span class="type">String</span>] = [] <span class="comment">// 参数名</span></span><br><span class="line">    <span class="keyword">var</span> methodName: <span class="type">String</span> = <span class="string">""</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个方法的调用者可能是一个变量，也可能是另一个方法调用的返回值（链式调用），所以<code>invoker</code>被定义为一个枚举值。</p>
<p>OC方法调用的Parser由类<code>ObjcMessageSendParser</code>实现，swift方法调用的Parse由类<code>SwiftInvokeParser</code>实现。以OC为例，对于这样的简单调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.view insertSubview:subview atIndex:0];</span><br></pre></td></tr></table></figure>
<p>匹配的结果为:<code>[self.view insertSubview: atIndex:]</code>，忽略参数的具体内容。对于链式的方法调用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[self objectAtIndex: 1] doSomethingWith: param];</span><br></pre></td></tr></table></figure>
<p>解析的结果只保留一个链式调用的表示：<code>[[self objectAtIndex:] doSomethingWith:]</code>，而不是<code>objectAtIndex:</code>和<code>doSomethingWith:</code>。</p>
<p>而对于一些更加复杂的形式，如参数为一个Block的定义，Block中还调用了其他方法，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Post globalTimelinePostsWithBlock:^(NSArray *posts, NSError *error) &#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        self.posts = posts;</span><br><span class="line">        [self.tableView reloadData];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>先看看对于OC方法调用文法的一个简单定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message_send = <span class="string">'['</span> receiver param_list <span class="string">']'</span></span><br><span class="line">receiver = message_send | NAME</span><br><span class="line">param_list = NAME | (NAME <span class="string">':'</span> param)+</span><br><span class="line">param = ...</span><br></pre></td></tr></table></figure>
<p>方法调用中具体的参数是通过规则<code>param</code>来解析的，<code>param</code>要知道自己当前是否位于另一个闭包或是其他子结构中，这样才能在正确的时机结束匹配，这一步可以通过计算左右括号的数量来判断，<code>param</code>在碰到另一个方法调用语句时进入<code>message_send</code>规则并将结果添加到最后的匹配结果中，伪代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">param</span><span class="params">()</span></span> <span class="keyword">throws</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> 文件未结束 &#123;</span><br><span class="line">            <span class="keyword">if</span> 不在子结构中 &amp;&amp; 参数匹配结束 &#123;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> isMessageSend() &#123;</span><br><span class="line">                <span class="keyword">try</span> messageSend() <span class="comment">// 匹配方法调用</span></span><br><span class="line">				保存到最终的匹配结果中</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            consume()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>以上就是Drafter实现的基本思路，开头提到的三个问题基本上得到了解决。在这段时间的工作中Drafter给了我不少帮助，至少当我在面对一个这样的文件：</p>
<p><img src="/images/1.png" alt=""></p>
<p>以及动辄数百行的方法时不再那么头疼，导出指定方法的调用流可以更迅速的理清代码逻辑上的关系：</p>
<p><img src="/images/2.png" alt=""></p>
<p>之后如果有需要的话会为Drafter添加更多的功能、增强解析能力等，希望这个小工具能稍微减轻你在阅读代码时的负担😁。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/13/RxSwift学习记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/13/RxSwift学习记录/" itemprop="url">RxSwift学习记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-13T18:35:13+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>在RxSwift中，最关键的一个概念是可观察序列（Observable Sequence），它相当于Swift中的序列（Sequence），可观察序列中的每个元素都是一个事件，我们知道Swift的序列中可以包含任意多个元素，类似的，可观察序列会不断产生新的事件直到发生错误或正常结束为止。订阅者（Observer）通过订阅（subscribe）一个可观察队列来接收序列所产生的新事件，只有在有观察者的情况下序列才可以发送事件。</p>
<p>例如，使用<code>of</code>操作创建一个可观察序列（以下简称为Observable）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><code>of</code>是一种用来创建Observable的简便操作，在上面的代码中创建了一个类型为<code>Observable&lt;Int&gt;</code>的Observable，里面包含了三个元素：1，2，3。</p>
<p>来看看Observable中都提供了哪些操作，可观察序列是一个实现了<code>ObservableType</code>协议的类型，<code>ObservableType</code>协议的定义非常简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ObservableType</span> : <span class="title">ObservableConvertibleType</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">E</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span>&lt;O: ObserverType&gt;<span class="params">(<span class="number">_</span> observer: O)</span></span> -&gt; <span class="type">Disposable</span> <span class="keyword">where</span> <span class="type">O</span>.<span class="type">E</span> == <span class="type">E</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>E</code>是一个关联类型，表示序列中元素的类型，除此之外协议只定义了一个方法：<code>subscribe</code>，用于向可观察序列添加一个观察者（<code>ObserverType</code>类型）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收闭包的subscribe函数是通过协议扩展提供的简便方法</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>subscribe</code>相当于Swift序列中的遍历操作（makeIterator），如上，向seq序列添加一个观察者，在序列中有新的事件时调用该闭包，上面的代码会输出1，2，3。</p>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>观察者是实现了<code>ObserverType</code>协议的对象，<code>ObserverType</code>协议同样十分简单：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ObserverType</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">E</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">on</span><span class="params">(<span class="number">_</span> event: Event&lt;E&gt;)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>E</code>为观察者所观察序列中的元素类型，当序列中有新的事件产生时，会调用<code>on</code>方法来接收新的事件。其中事件的类型<code>Event</code>是一个枚举，其中包含3个类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> next(<span class="type">Element</span>)</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>.next</code>：表示序列中产生了下一个事件，关联值Element保存了该事件的值。</li>
<li><code>.error</code>：序列产生了一个错误，关联值Error保存了错误类型，在这之后序列会直接结束(不再产生新的next事件)。</li>
<li><code>.completed</code>：序列正常结束。</li>
</ol>
<h2 id="Dispose"><a href="#Dispose" class="headerlink" title="Dispose"></a>Dispose</h2><p>除了产生错误和自然结束以外，还可以手动结束观察，在使用<code>subscribe</code>订阅一个可观察序列时，会返回一个<code>Disposable</code>类型的对象。这里的<code>Disposable</code>是一个协议，只定义了一个方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Disposable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">dispose</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>dispose</code>方法用来结束此次订阅并释放可观察序列中的相关资源，通常来说你并不需要直接调用该方法，而是通过调用其扩展方法<code>addDisposableTo</code>将<code>Disposable</code>添加到一个<code>DisposeBag</code>对象中。DisposeBag对象会自动管理所有添加到其中的Disposable对象，在DisposeBag对象销毁的时候会自动调用其中所有Disposable的dispose方法释放资源。</p>
<p>也可以使用<code>takeUntil</code>来自动结束订阅：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq.takeUntil(otherSeq)</span><br><span class="line">	.subscribe(&#123; (event) <span class="keyword">in</span></span><br><span class="line">    	<span class="built_in">print</span>(event)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>在otherSeq序列发出任意类型的事件之后，自动结束本次订阅。</p>
<h2 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h2><p>通过<code>Observable</code>类型提供的方法<code>create</code>可以创建一个自定义的可观察序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.create &#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">    observer.on(.next(<span class="number">1</span>))</span><br><span class="line">    observer.on(.completed)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;</span><br><span class="line">        <span class="comment">// do some cleanup</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>create</code>方法使用一个闭包来创建自定义的序列，闭包接收一个<code>ObserverType</code>的参数observer，并通过observer来发送相应的事件。如上面的代码，创建了一个<code>Observable&lt;Int&gt;</code>类型的可观察序列，订阅该序列的观察者会收到事件1和一个完成事件。最后<code>create</code>方法返回一个自己创建的<code>Disposable</code>对象，可以在这里进行一些相关的资源回收操作。</p>
<p>除了<code>create</code>方法之外，RxSwift中提供了很多中简便的方法用于创建序列，常用的有：</p>
<ul>
<li><p><strong>just</strong>：创建一个只包含一个值的可观察序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> justSeq = <span class="type">Observable</span>.just(<span class="number">1</span>)</span><br><span class="line">justSeq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>of</strong>：<code>of</code>和<code>just</code>有点类似，不同的是<code>of</code>可以将一系列元素创建成事件队列，该<code>Observable</code>依次发送相应事件和结束事件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ofSeq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">ofSeq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>empty</strong>：这种类型的Observable只发送结束(Completed)事件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptySequence = <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.empty()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>error</strong>：该队列只发送一个<code>error</code>事件，传递一个自定义的错误类型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> errorSeq = <span class="type">Observable</span>&lt;<span class="type">TestError</span>&gt;.error(<span class="type">TestError</span>.<span class="type">Error1</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Share"><a href="#Share" class="headerlink" title="Share"></a>Share</h2><p>通常在我们在订阅一个可观察序列的时候，每一次的订阅行为都是独立的，也就是说：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 1: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 2: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">1</span>)</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">2</span>)</span><br><span class="line">sub <span class="number">1</span>: completed </span><br><span class="line">sub <span class="number">2</span>: next(<span class="number">1</span>)</span><br><span class="line">sub <span class="number">2</span>: next(<span class="number">2</span>)</span><br><span class="line">sub <span class="number">2</span>: completed</span><br></pre></td></tr></table></figure>
<p>我们连续订阅同一序列两次，每次都会接收到相同的事件，第二次订阅时并没有因为第一次订阅的行为导致元素”耗尽”。有些时候我们希望让所有的观察者都共享同一份事件，这个时候可以使用<code>share</code></p>
<ul>
<li><p><strong>share</strong>：<code>share</code>是<code>ObservableType</code>协议的一个扩展方法，它返回一个可观察序列，该序列的所有观察者都会共享同一份订阅，上面的代码加上share之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>).share()</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 1: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sub 2: <span class="subst">\(event)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">1</span>)</span><br><span class="line">sub <span class="number">1</span>: next(<span class="number">2</span>)</span><br><span class="line">sub <span class="number">1</span>: completed </span><br><span class="line">sub <span class="number">2</span>: completed</span><br></pre></td></tr></table></figure>
<p>可以看到，在第一次订阅时序列已经将所有的事件发送，后面再进行第二次订阅的时候只收到了一个完成事件。</p>
</li>
<li><p><strong>shareReplay</strong>：<code>shareReplay</code>的用法与<code>share</code>类似，它的方法签名如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">shareReplay</span><span class="params">(<span class="number">_</span> bufferSize: Int)</span></span> -&gt; <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;</span><br></pre></td></tr></table></figure>
<p>不同的地方在于，<code>shareReplay</code>接收一个整型参数bufferSize，指定缓冲区大小，订阅该序列的观察者会立即收到最近bufferSize条事件。</p>
</li>
</ul>
<h2 id="序列的变换和组合"><a href="#序列的变换和组合" class="headerlink" title="序列的变换和组合"></a>序列的变换和组合</h2><p>在Swift的序列<code>Sequence</code>中，可以使用map、flatMap和reduce等常见的函数式方法对其中的元素进行变换，RxSwift中的可观察序列同样也支持这些方法。</p>
<h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><ul>
<li><p><strong>map</strong>：这是<code>map</code>方法的签名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;Result&gt;<span class="params">(<span class="number">_</span> transform: @escaping <span class="params">(E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">Result</span>) -&gt; <span class="type">Observable</span>&lt;<span class="type">Result</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在一个自定义的闭包中对序列的每一个元素进行变换，返回一个包含转换后结果的可观察序列，与Swift中<code>Sequence</code>的map类似。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mappedSeq: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = seq.<span class="built_in">map</span> &#123; (element) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">	<span class="keyword">return</span> <span class="string">"value: <span class="subst">\(element)</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>flatMap</strong>：先来看看<code>flatMap</code>的签名：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;O: ObservableConvertibleType&gt;<span class="params">(<span class="number">_</span> selector: @escaping <span class="params">(E)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">O</span>)</span><br><span class="line">        -&gt; <span class="type">Observable</span>&lt;<span class="type">O</span>.<span class="type">E</span>&gt;</span><br></pre></td></tr></table></figure>
<p>关于flatMap的作用同样可以类比<code>Sequence</code>，<code>Sequence</code>中的<code>flatMap</code>闭包遍历每一个元素进行处理后返回一个新的序列，最后会将这些序列”展平”，得到一个包含所有序列元素的新序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">let</span> res = array.flatMap &#123; (n) -&gt; [<span class="type">String</span>] <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="string">"<span class="subst">\(n)</span>a"</span>, <span class="string">"<span class="subst">\(n)</span>b"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// res: ["1a", "1b", "2a", "2b"]</span></span><br></pre></td></tr></table></figure>
<p>RxSwift中的<code>flatMap</code>用法与之类似，<code>flatMap</code>中的闭包会遍历可观察序列中的所有元素，并返回一个新的可观察序列，最后<code>flatMap</code>会返回一个包含所有元素的可观察序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .flatMap &#123; (n) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="string">"<span class="subst">\(n)</span>a"</span>, <span class="string">"<span class="subst">\(n)</span>b"</span>) <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 得到的seq类型为Observable&lt;String&gt;</span></span><br><span class="line">---- example output ----</span><br><span class="line">next(1a)</span><br><span class="line">next(1b)</span><br><span class="line">next(2a)</span><br><span class="line">next(2b)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>在闭包中创建了若干个可观察序列(1)，这些序列中发送的<code>next</code>事件都会被传递到seq序列中，其中任何一个序列发生错误（发送了<code>error</code>事件）时，seq序列都会直接结束，不再继续接收事件；但是只有所有序列都完成（发送了<code>completed</code>事件）后，seq序列才会正常结束。</p>
</li>
<li><p><strong>flatMapLatest</strong>：作用与<code>flatMap</code>类似，但是对于闭包中生成的可观察序列，它并不会保留所有的序列的订阅，在遍历结束后，只保留最后创建的序列的订阅，之前创建的Observables都会取消订阅（相应序列的dispose方法也会被调用）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与上一个例子相同的代码，仅将flatMap改成flatMapLatest</span></span><br><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .flatMapLatest &#123; (n) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>.of(<span class="string">"<span class="subst">\(n)</span>a"</span>, <span class="string">"<span class="subst">\(n)</span>b"</span>) <span class="comment">// (1)</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(1a)</span><br><span class="line">next(2a)</span><br><span class="line">next(2b)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>因为订阅关系的改变，现在只有当最后创建的那个Observable正常结束时，seq才会收到<code>completed</code>事件。</p>
<p>在这种情况下，<code>flatMapLatest</code>会得到与<code>flatMap</code>相同的输出：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .flatMapLatest &#123; (n) -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create(&#123; (observer) -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">            observer.onNext(<span class="string">"<span class="subst">\(n)</span>a"</span>)</span><br><span class="line">            observer.onNext(<span class="string">"<span class="subst">\(n)</span>b"</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这是因为在上面的这个例子中所创建的Observable是同步创建元素的，无法被打断。</p>
<p>类似的方法还有<code>flatMapFirst</code>，使用方法可以类比<code>flatMapLatest</code>。</p>
</li>
<li><p><strong>reduce和scan</strong>：<code>reduce</code>的作用与Sequence中定义的一样，它接收一个初始值和一个闭包，在Observable中的每个值上调用该闭包，并将每一步的结果作为下一次调用的输入：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; (first, num) -&gt; <span class="type">Float</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Float</span>(first + num)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出：next(6.0), completed</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，提供了一个初始值0，在闭包中计算和，并将结果序列的元素类型改成<code>Float</code>，序列的观察者最后接收到所有元素的和。</p>
<p><code>scan</code>的作用类似于<code>reduce</code>，它跟<code>reduce</code>之间唯一的区别在于，<code>scan</code>会发送每一次调用闭包后的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>).scan(<span class="number">0</span>) &#123; (first, num) -&gt; <span class="type">Float</span> <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">Float</span>(first + num)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 输出：next(1.0), next(3.0), next(6.0), completed</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul>
<li><p><strong>startWith</strong>：在序列的开头加入一个指定的元素</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Observable</span>.of(<span class="number">2</span>, <span class="number">3</span>).startWith(<span class="number">1</span>).subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>订阅该序列之后，会立即收到<code>startWith</code>指定的事件，即使此时序列并没有开始发送事件。</p>
</li>
<li><p><strong>merge</strong>：当你有多个类型相同的Observable，可以使用<code>merge</code>方法将它们合并起来，同时订阅所有Observable中的事件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq1 = <span class="type">Observable</span>.just(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> seq2 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(seq1, seq2).merge()</span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>只有当Observable中的元素也是Observable类型的时候才可以使用<code>merge</code>方法，当其中一个序列发生错误的时候，seq都会被终止，同样的只有所有序列都完成之后，seq才会收到完成事件。</p>
</li>
<li><p><strong>zip</strong>：<code>zip</code>方法也可以将多个Observable合并在一起，与<code>merge</code>不同的是，<code>zip</code>提供了一个闭包用来对多个Observable中的元素进行组合变化，最后获得一个新的序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> seq1 = <span class="type">Observable</span>.just(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> seq2 = <span class="type">Observable</span>.just(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> seq: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = <span class="type">Observable</span>.<span class="built_in">zip</span>(seq1, seq2) &#123; (num1, num2) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"<span class="subst">\(num1 + num2)</span>"</span></span><br><span class="line">&#125;</span><br><span class="line">seq.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">3</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p><code>zip</code>方法按照参数个数的不同有多个版本，最多支持合并8个可观察序列，需要注意的一点是，闭包所接收的参数是各个序列中对应位置的元素。也就是说，如果seq1发送了一个事件，而seq2发送了多个事件，闭包也只会被执行一次，seq中只有一个元素。</p>
<p>组合的Observable中任意一个发生错误，最后的seq都会直接出错终止，当所有的Observable都发出completed事件后，seq才会正常结束。</p>
</li>
<li><p><strong>combineLatest</strong>：<code>combineLatest</code>同样用于将多个序列组合成一个，使用方法与<code>zip</code>一样，但是它的调用机制跟<code>zip</code>不同，每当其中一个序列有新元素时，<code>combineLatest</code>都会从其他所有序列中取出最后一个元素，传入闭包中生成新的元素添加到结果序列中。</p>
</li>
</ul>
<h2 id="Subject"><a href="#Subject" class="headerlink" title="Subject"></a>Subject</h2><p><code>Subject</code>对象相当于一种中间的代理和桥梁的作用，它既是观察者又是可观察序列，在向一个<code>Subject</code>对象添加观察者之后，可以通过该<code>Subject</code>向其发送事件。<code>Subject</code>对象并不会主动发送completed事件，并且在发送了error或completed事件之后，<code>Subject</code>中的序列会直接终结，无法再发送新的消息。<code>Subject</code>同样也分为几种类型：</p>
<ul>
<li><p><strong>PublishSubject</strong>：<code>PublishSubject</code>的订阅者只会收到在其订阅（subscribe）之后发送的事件</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">Int</span>&gt;()</span><br><span class="line">subject.onNext(<span class="number">1</span>)</span><br><span class="line">subject.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">subject.onNext(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到，观察者只收到了事件2，在订阅之前发送的事件1并没有接收到。</p>
</li>
<li><p><strong>ReplaySubject</strong>：<code>ReplaySubject</code>在初始化时指定一个大小为n的缓冲区，里面会保存最近发送的n条事件，在订阅之后，观察者会立即收到缓冲区中的事件：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">Int</span>&gt;.create(bufferSize: <span class="number">2</span>)</span><br><span class="line">subject.onNext(<span class="number">1</span>)</span><br><span class="line">subject.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">subject.onNext(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>BehaviorSubject</strong>：<code>BehaviorSubject</code>在初始化时需要提供一个默认值，在订阅时观察者会立刻收到序列上一次发送的事件，如果没有发送过事件则会收到默认值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="number">1</span>)</span><br><span class="line">subject.subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Variable</strong>：<code>Variable</code>是对<code>BehaviorSubject</code>的一个封装，行为上与<code>BehaviorSubject</code>类似。<code>Variable</code>没有<code>on</code>之类的方法来发送事件，取而代之的是一个<code>value</code>属性，向<code>value</code>赋值可以向观察者发送next事件，并且访问<code>value</code>可以获取最后一次发送的数据：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> variable = <span class="type">Variable</span>(<span class="number">1</span>)</span><br><span class="line">variable.asObservable().subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(event)</span><br><span class="line">&#125;</span><br><span class="line">variable.value = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">---- example output ----</span><br><span class="line">next(<span class="number">1</span>)</span><br><span class="line">next(<span class="number">2</span>)</span><br><span class="line">completed</span><br></pre></td></tr></table></figure>
<p>与其他Subject类型不同的是，<code>Variable</code>在释放的时候会发送completed事件，并且<code>Variable</code>对象永远不会发送error事件。</p>
</li>
</ul>
<h2 id="Scheduler"><a href="#Scheduler" class="headerlink" title="Scheduler"></a>Scheduler</h2><p><code>Scheduler</code>是RxSwift中进行多线程编程的一种方式，一个Observable在执行的时候会指定一个<code>Scheduler</code>，这个<code>Scheduler</code>决定了在哪个线程对序列进行操作以及事件回调。默认情况下，在订阅Observable之后，观察者会在与调用<code>subscribe</code>方法时相同的线程收到通知，并且也会在该线程进行销毁（dispose）。</p>
<p>与GCD类似，<code>Scheduler</code>分为串行（serial）和并行（concurrent）两种类型，RxSwift中定义了几种Schedular：</p>
<ul>
<li><strong>CurrentThreadScheduler</strong>：这是默认的Scheduler，代表了当前的线程，serial类型。</li>
<li><strong>MainScheduler</strong>：表示主线程，serial类型</li>
<li><strong>SerialDispatchQueueScheduler</strong>：提供了一些快捷的方法来创建串行Scheduler，内部封装了DispatchQueue</li>
<li><strong>ConcurrentDispatchQueueScheduler</strong>：提供了快捷的方法来创建并行Scheduler，同样封装了DispatchQueue</li>
</ul>
<h3 id="subscribeOn和observeOn"><a href="#subscribeOn和observeOn" class="headerlink" title="subscribeOn和observeOn"></a>subscribeOn和observeOn</h3><p><code>subscribeOn</code>和<code>observeOn</code>是其中两个最重要的方法，它们可以改变Observable所在的Scheduler：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main thread</span></span><br><span class="line"><span class="keyword">let</span> scheduler = <span class="type">ConcurrentDispatchQueueScheduler</span>(qos: .<span class="keyword">default</span>)</span><br><span class="line"><span class="keyword">let</span> seq = <span class="type">Observable</span>.of(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">seq.subscribeOn(scheduler)</span><br><span class="line">    .<span class="built_in">map</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">0</span> * <span class="number">2</span> <span class="comment">// 子线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe &#123; (event) <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(event) <span class="comment">// 子线程</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中创建了一个并发的Scheduler，并在序列seq上调用<code>subscribeOn</code>指定了该Scheduler，可以看到，我们在主线程中订阅该序列，但是<code>map</code>方法以及事件的回调都是在创建的子线程中执行。</p>
<p><code>subscribeOn</code>和<code>observeOn</code>都可以指定序列的Scheduler，它们之间的区别在于：</p>
<ul>
<li><code>subscribeOn</code>设定了整个序列开始的时候所在的Scheduler，序列在创建以及之后的操作都会在这个Scheduler上进行，<code>subscribeOn</code>在整个链式调用中只能调用一次，之后再次调用<code>subscribeOn</code>没有任何效果。</li>
<li><code>observeOn</code>指定一个Scheduler，在这之后的操作都会被派发到这个Scheduler上执行，<code>observeOn</code>可以在链式操作的中间改变Scheduler</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">createObservable().</span><br><span class="line">	.doSomething()</span><br><span class="line">	.subscribeOn(scheduler1) <span class="comment">// (1)</span></span><br><span class="line">	.doSomethingElse()</span><br><span class="line">	.observeOn(scheduler2) <span class="comment">// (2)</span></span><br><span class="line">	.doAnother()</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p>如上代码，在(1)处执行了<code>subscribeOn</code>之后，之前的操作createObservable()和doSomething()都会在scheduler1中执行，随后的doSomethingElse()同样也在scheduler1中执行，随后用<code>observeOn</code>指定了另外一个scheduler2，之后的doAnother()会在scheduler2上执行。</p>
<h2 id="为原有代码添加Rx扩展"><a href="#为原有代码添加Rx扩展" class="headerlink" title="为原有代码添加Rx扩展"></a>为原有代码添加Rx扩展</h2><p>RxSwift中提供了一种扩展机制，可以很方便的为原有的代码添加上Rx扩展。首先来看一个结构体<code>Reactive</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/// base是扩展的对象实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.base = base</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Reactive</code>是一个泛型结构体，只定义了一个属性<code>base</code>，并且在初始化结构体的时候传入该属性的值。</p>
<p>此外还定义了一个协议<code>ReactiveCompatible</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ReactiveCompatible</span> </span>&#123;</span><br><span class="line">    associatedtype <span class="type">CompatibleType</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">CompatibleType</span>&gt;.<span class="type">Type</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">CompatibleType</span>&gt; &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该协议中分别为类对象和实例对象定义一个名字相同的属性：<code>rx</code>，类型为上面定义的<code>Reactive</code>，随后通过协议扩展为其提供了<code>get</code>的默认的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReactiveCompatible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt;.<span class="type">Type</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt;.<span class="keyword">self</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// this enables using Reactive to "mutate" base type</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Reactive</span>(<span class="keyword">self</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="comment">// this enables using Reactive to "mutate" base object</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关联类型<code>CompatibleType</code>被自动推导为实现该协议的类本身，使用<code>self</code>初始化一个<code>Reactive</code>对象。</p>
<p>最后通过协议扩展为所有的NSObject类型实现了<code>ReactiveCompatible</code>协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span>: <span class="title">ReactiveCompatible</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，代码中所有继承自NSObject的类型实例中都会有一个类型为<code>Reactive</code>的属性<code>rx</code>，当我们要为自己的类型添加Rx扩展时，只需要通过扩展向<code>Reactive</code>中添加方法就可以了，例如向UIButton类型添加扩展：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIButton</span> </span>&#123; <span class="comment">// 为Reactive&lt;UIButton&gt;添加扩展</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> tap: <span class="type">ControlEvent</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> controlEvent(.touchUpInside) <span class="comment">// 通过base可以访问该实例本身</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于<code>Reactive</code>是一个泛型类型，我们可以通过where语句指定泛型的类型，这样一来，我们就可以在UIButton实例的rx中访问tap属性了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="type">UIButton</span>(...)</span><br><span class="line">button.rx.tap</span><br></pre></td></tr></table></figure>
<p>类似RxCocoa这样的RxSwift扩展库都是通过这种方式进行Rx扩展的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/13/在iOS项目中自动生成函数调用关系图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/13/在iOS项目中自动生成函数调用关系图/" itemprop="url">在iOS项目中自动生成函数调用关系图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-13T17:35:13+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在平时的开发中经常需要阅读学习其他人的代码，当开始阅读一份自己完全不熟悉的代码时，通常会遇到一些麻烦，因为我必须要先找到代码逻辑的入口点并沿着逻辑链路将其梳理一遍，一份代码文件通常会伴随着许多的方法调用，这一个阶段往往是比较痛苦的，因为我必须花上许多时间来将这些方法之间的关系理清楚，这样才能在我的大脑中生成一份逻辑关系图。如果我们能自动生成源码中的方法调用图(Call Graph)，那样一定会对源码阅读有很大的帮助。  </p>
<p>我们需要一个能够自动生成源码方法调用图的工具，那么这个工具必须能够理解并分析我们的代码，而最能理解代码的当然就是编译器了。我们编译Objective-C的代码所用的前端是Clang，Clang提供了一系列的工具来帮助我们分析源码，我们可以基于Clang来构建自己的工具。在这之前简单介绍一些相关概念：</p>
<h3 id="抽象语法树"><a href="#抽象语法树" class="headerlink" title="抽象语法树"></a>抽象语法树</h3><p>抽象语法树（Abstract Syntax Code, AST）是源代码语法结构的树状表示，其中的每一个节点都表示一个源码中的结构，AST在编译中扮演了一个十分重要的角色，Clang分析输入的源码并生成AST，之后根据AST生成LLVM IR(中间码)。  </p>
<p>我们可以使用Clang提供的工具<code>clang-check</code>来查看AST，创建一个代码文件test.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> result = square(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在终端执行命令<code>clang-check -ast-dump test.m</code>，可以看到转换后的AST结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|-FunctionDecl 0x7fa933840e00 &lt;/Users/lzephyr/Desktop/test.c:1:1, line:3:1&gt; line:1:5 used square &apos;int (int)&apos;</span><br><span class="line">| |-ParmVarDecl 0x7fa93302f720 &lt;col:12, col:16&gt; col:16 used num &apos;int&apos;</span><br><span class="line">| `-CompoundStmt 0x7fa933840fa0 &lt;col:21, line:3:1&gt;</span><br><span class="line">|   `-ReturnStmt 0x7fa933840f88 &lt;line:2:2, col:15&gt;</span><br><span class="line">|     `-BinaryOperator 0x7fa933840f60 &lt;col:9, col:15&gt; &apos;int&apos; &apos;*&apos;</span><br><span class="line">|       |-ImplicitCastExpr 0x7fa933840f30 &lt;col:9&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|       | `-DeclRefExpr 0x7fa933840ee0 &lt;col:9&gt; &apos;int&apos; lvalue ParmVar 0x7fa93302f720 &apos;num&apos; &apos;int&apos;</span><br><span class="line">|       `-ImplicitCastExpr 0x7fa933840f48 &lt;col:15&gt; &apos;int&apos; &lt;LValueToRValue&gt;</span><br><span class="line">|         `-DeclRefExpr 0x7fa933840f08 &lt;col:15&gt; &apos;int&apos; lvalue ParmVar 0x7fa93302f720 &apos;num&apos; &apos;int&apos;</span><br><span class="line">`-FunctionDecl 0x7fa933841010 &lt;line:5:1, line:7:1&gt; line:5:5 main &apos;int ()&apos;</span><br><span class="line">  `-CompoundStmt 0x7fa9338411f8 &lt;col:12, line:7:1&gt;</span><br><span class="line">    `-DeclStmt 0x7fa9338411e0 &lt;line:6:2, col:24&gt;</span><br><span class="line">      `-VarDecl 0x7fa9338410c0 &lt;col:2, col:23&gt; col:6 result &apos;int&apos; cinit</span><br><span class="line">        `-CallExpr 0x7fa9338411b0 &lt;col:15, col:23&gt; &apos;int&apos;</span><br><span class="line">          |-ImplicitCastExpr 0x7fa933841198 &lt;col:15&gt; &apos;int (*)(int)&apos; &lt;FunctionToPointerDecay&gt;</span><br><span class="line">          | `-DeclRefExpr 0x7fa933841120 &lt;col:15&gt; &apos;int (int)&apos; Function 0x7fa933840e00 &apos;square&apos; &apos;int (int)&apos;</span><br><span class="line">          `-IntegerLiteral 0x7fa933841148 &lt;col:22&gt; &apos;int&apos; 2</span><br></pre></td></tr></table></figure></p>
<h3 id="LibTooling和Clang-Plugin"><a href="#LibTooling和Clang-Plugin" class="headerlink" title="LibTooling和Clang Plugin"></a>LibTooling和Clang Plugin</h3><p><code>LibTooling</code>是一个库，提供了对AST的访问和修改的能力，<code>LibTooling</code>可以用来编写可独立运行的程序，如我们上面所使用的<code>clang-check</code>，<code>LibTooling</code>提供了一系列便捷的方法来访问语法树。  </p>
<p><code>Clang Plugin</code>与<code>LibTooling</code>类似，对AST有完全的控制权，但是不同的是<code>Clang Plugin</code>是作为插件注入到编译流程中的，并且可以嵌入xCode中。实际上使用<code>LibTooling</code>编写的独立工具只需要经过少许的改动就可以变成<code>Clang Plugin</code>来使用。</p>
<h2 id="访问抽象语法树"><a href="#访问抽象语法树" class="headerlink" title="访问抽象语法树"></a>访问抽象语法树</h2><p>要获得函数之间的调用关系，我们必须分析AST，Clang提供了两种方法：<code>ASTMatchers</code>和<code>RecursiveASTVisitor</code>。</p>
<h3 id="ASTMatchers"><a href="#ASTMatchers" class="headerlink" title="ASTMatchers"></a>ASTMatchers</h3><p><code>ASTMatchers</code>提供了一系列的函数，以DSL的方式编写匹配表达式来查找我们感兴趣的节点，并使用<code>bind</code>方法绑定到指定的名称上：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StatementMatcher matcher = callExpr(hasAncestor(functionDecl().bind(<span class="string">"caller"</span>)), </span><br><span class="line">                                    callee(functionDecl().bind(<span class="string">"callee"</span>)));</span><br></pre></td></tr></table></figure></p>
<p>上面的表达式匹配了源码中普通C函数的调用，并将调用者绑定到字符串”caller”，被调用者绑定到字符串”callee”，随后在回调方法中可以通过名称caller和callee来获取<code>FunctionDecl</code>类型的对象：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindFuncCall</span> :</span> <span class="keyword">public</span> MatchFinder::MatchCallback &#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> MatchFinder::MatchResult &amp;Result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取调用者的函数定义</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> FunctionDecl *caller = Result.Nodes.getNodeAs&lt;clang::FunctionDecl&gt;(<span class="string">"caller"</span>)) &#123;</span><br><span class="line">            caller-&gt;dump();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取被调用者的函数定义</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> FunctionDecl *callee = Result.Nodes.getNodeAs&lt;clang::FunctionDecl&gt;(<span class="string">"callee"</span>)) &#123;</span><br><span class="line">            callee-&gt;dump();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">const</span> <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">	StatementMatcher matcher = callExpr(hasAncestor(functionDecl().bind(<span class="string">"caller"</span>)),</span><br><span class="line">                                        callee(functionDecl().bind(<span class="string">"callee"</span>)));</span><br><span class="line">    MatchFinder finder;</span><br><span class="line">    FindFuncCall callback;</span><br><span class="line">    finder.addMatcher(matcher, &amp;callback);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 执行Matcher</span></span><br><span class="line">    <span class="function">CommonOptionsParser <span class="title">OptionsParser</span><span class="params">(argc, argv, MyToolCategory)</span></span>;</span><br><span class="line">    ClangTool Tool(OptionsParser.getCompilations(), OptionsParser.getSourcePathList());</span><br><span class="line">    Tool.run(newFrontendActionFactory(&amp;finder).get());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述匹配表达式中的每一个函数(如callExpr)被称为一个<code>Matcher</code>，所有的<code>Matcher</code>可以分为三类：</p>
<ul>
<li><p><strong>Node Matchers</strong>：匹配表达式的核心，用来匹配特定类型的所有节点，所有的匹配表达式都是由一个<code>Node Matcher</code>来开始的，并且只有在<code>Node Matcher</code>上可以调用<code>bind</code>方法。<code>Node Mathcher</code>可以包含任意数量的参数，在参数中传入其他的Matcher来操纵匹配的节点，但是需要注意的是所有作为参数传入的Matcher都会作用在同一个被匹配的节点上，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeclarationMatcher matcher = recordDecl(cxxRecordDecl().bind(&quot;class&quot;),</span><br><span class="line">										hasName(&quot;MyClass&quot;));</span><br></pre></td></tr></table></figure>
<p>该matcher的含义是查找名字为“MyClass”的c++类，<code>recordDecl</code>是一个<code>Node Matcher</code>，匹配所有的class、struct和union的定义；<code>hasName</code>匹配名字为”MyClass”的节点；<code>cxxRecordDecl</code>匹配C++类定义的节点，并将其绑定到字符串”class”上。</p>
</li>
<li><strong>Narrowing Matchers</strong>：顾名思义，这种Matcher提供了条件判断能力用来缩小匹配范围，如第二个例子中的<code>hasName</code>就是一个<code>Narrowing Matcher</code>，只匹配名称为”MyClass”的节点。</li>
<li><strong>Traversal Matchers</strong>：以当前匹配的节点作为起点，用来限定匹配表达式查找的范围。如第一个例子中的<code>hasAncestor</code>，在当前节点的祖先节点中进行下一步的匹配。</li>
</ul>
<h3 id="RecursiveASTVisitor"><a href="#RecursiveASTVisitor" class="headerlink" title="RecursiveASTVisitor"></a>RecursiveASTVisitor</h3><p><code>RecursiveASTVisitor</code>是Clang提供的另一种访问AST的方式，使用起来很简单，你需要定义三个类，分别继承自<code>ASTFrontendAction</code>、<code>ASTConsumer</code>和<code>RecursiveASTVisitor</code>。<br>在自定义的MyFrontendAction中返回一个自定义的MyConsumer实例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrontendAction</span> :</span> <span class="keyword">public</span> clang::ASTFrontendAction &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt; CreateASTConsumer(</span><br><span class="line">      clang::CompilerInstance &amp;Compiler, llvm::StringRef InFile) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;clang::ASTConsumer&gt;(<span class="keyword">new</span> MyConsumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在AST解析完毕后会调用MyConsumer的<code>HandleTranslationUnit</code>方法，<code>TranslationUnitDecl</code>是一个AST的根节点，<code>ASTContext</code>中保存了AST相关的所有信息，获取<code>TranslationUnitDecl</code>并将其交给MyVisitor，我们主要的操作都在Visitor中完成<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> :</span> <span class="keyword">public</span> clang::ASTConsumer &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">HandleTranslationUnit</span><span class="params">(clang::ASTContext &amp;Context)</span> </span>&#123;</span><br><span class="line">      Visitor.TraverseDecl(Context.getTranslationUnitDecl());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  	MyVisitor Visitor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在Visitor中访问感兴趣的节点只需要重写该类型节点的Visit方法就行了，比如我想访问代码中所有的C++类定义，只需要重写<code>VisitCXXRecordDecl</code>方法，就可以访问所有的的所有的C++类定义了<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVisitor</span> :</span> <span class="keyword">public</span> RecursiveASTVisitor&lt;FindNamedClassVisitor&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  	<span class="function"><span class="keyword">bool</span> <span class="title">VisitCXXRecordDecl</span><span class="params">(CXXRecordDecl *decl)</span> </span>&#123;</span><br><span class="line">    	decl-&gt;dump();</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 返回true继续遍历，false则直接停止</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>之后在main函数中使用<code>newFrontendActionFactory</code>创建<code>ToolAction</code>就可以了:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tool.run(newFrontendActionFactory&lt;CallGraphAction&gt;().get());</span><br></pre></td></tr></table></figure></p>
<h2 id="构建CallGraph工具"><a href="#构建CallGraph工具" class="headerlink" title="构建CallGraph工具"></a>构建CallGraph工具</h2><p>在Clang源码中的<code>Analysis</code>文件夹中提供了一个名为<code>CallGraph</code>的类，参考这份源码的实现编写了自己的CallGraph工具。其中核心部分主要为三个类：<code>CallGraph</code>、<code>CallGraphNode</code>和<code>CGBuilder</code>：</p>
<ul>
<li><p><strong>CallGraph</strong>：继承自<code>RecursiveASTVisitor</code>，实现<code>VisitFunctionDecl</code>和<code>VisitObjCMethodDecl</code>方法，遍历所有的C函数和Objective-C方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VisitObjCMethodDecl</span><span class="params">(ObjCMethodDecl *MD)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInSystem(MD)) &#123; <span class="comment">// 忽略系统库中的定义</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (canBeCallerInGraph(MD)) &#123;</span><br><span class="line">        addRootNode(MD); <span class="comment">// 添加一个Node到Roots</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>addRootNode</code>中将其封装成<code>CallGraphNode</code>对象并保存在一个map类型的成员对象<code>Roots</code>中。随后获取函数体(<code>CompoundStmt</code>类型)，将其传递给<code>CGBuilder</code>查找在函数体中被调用的方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CallGraph::addRootNode(Decl *decl) &#123;</span><br><span class="line">  CallGraphNode *Node = getOrInsertNode(decl); <span class="comment">// 将decl封装成Node，并添加到Roots中</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化CGBuilder遍历函数里中所有的方法调用</span></span><br><span class="line">  <span class="function">CGBuilder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, Node, Context)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (Stmt *Body = decl-&gt;getBody())</span><br><span class="line">      builder.Visit(Body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CallGraphNode</strong>：封装了一个<code>Decl</code>类型的的实例（C函数或OC方法的定义），用来表示一个AST节点，所有被该函数所调用的其他函数会被添加到vector类型的成员变量<code>CalledFunctions</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallGraphNode</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// C函数或OC方法的定义</span></span><br><span class="line">    Decl *decl;</span><br><span class="line">    <span class="comment">// 保存所有被decl调用的Node</span></span><br><span class="line">    SmallVector&lt;CallGraphNode*, <span class="number">5</span>&gt; CalledFunctions;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CGBuilder</strong>：继承自<code>StmtVisitor</code>，初始化时获取一个CallerNode，遍历该CallerNode对应函数的函数体，查找函数体中的方法调用：<code>CallExpr</code>和<code>ObjCMessageExpr</code>。<code>CallExpr</code>表示普通的C函数调用，<code>ObjCMessageExpr</code>表示Objective-C方法调用。获取被调用函数的定义并封装成<code>CallGraphNode</code>类型，然后将其添加到CallerNode的<code>CalledFunctions</code>中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CGBuilder</span> :</span> <span class="keyword">public</span> StmtVisitor&lt;CGBuilder&gt; &#123;</span><br><span class="line">  CallGraph *G;</span><br><span class="line">  CallGraphNode *CallerNode;</span><br><span class="line">  ASTContext &amp;Context;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">VisitObjCMessageExpr</span><span class="params">(ObjCMessageExpr *ME)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 从ObjCMessageExpr中获取被调用方法的Decl</span></span><br><span class="line">      Decl *decl = ...</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 将decl封装在CallGraphNode中并添加到CallerNode的CalledFunctions中</span></span><br><span class="line">      addCalledDecl(decl); </span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>目前只实现了一个基础版本，支持C和Objecive-C，实现了最基本的功能，代码也比较简单，之后会继续优化并增加新的功能，所有代码已经托管到github上：<a href="https://github.com/L-Zephyr/clang-mapper" target="_blank" rel="noopener">https://github.com/L-Zephyr/clang-mapper</a> </p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可以下载并自行编译源码，或者直接使用release文件夹中预先编译好的二进制文件<code>clang-mapper</code>(使用Clang5.0.0编译)，由于采用了<code>Graphviz</code>来生成调用图，请确保在运行前已正确安装了<code>Graphviz</code>  </p>
<h3 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h3><p>关于如何编译用LibTooling编写的工具，<a href="https://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="noopener">Clang官方文档</a>中有详细的说明</p>
<ol>
<li><p>首先下载LLVM和Clang的源码。</p>
</li>
<li><p>将<code>clang-mapper</code>文件夹拷贝到<code>llvm/tools/clang/tools/</code>中。</p>
</li>
<li><p>编辑文件<code>llvm/tools/clang/tools/CMakeLists.txt</code>，在最后加上一句<code>add_clang_subdirectory(clang-mapper)</code></p>
</li>
<li><p>建议采用外部编译，在包含llvm文件夹的目录下创建build文件夹，在build目录中编译源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake -G &apos;Unix Makefiles&apos; ../llvm</span><br><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>也可以按照文档中介绍的使用Ninja来编译，编译过程过会生成20多个G的中间文件，编译结束后在<code>build/bin/</code>中就能找到<code>clang-mapper</code>文件了，将其拷贝到<code>/usr/local/bin</code>目录下</p>
</li>
</ol>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>传入任意数量的文件或是文件夹，<code>clang-mapper</code>会自动处理所有文件并在当前执行命令的路径下生成函数的调用图，以代码文件的命名做区分。如下，我们用clang-mapper分析大名鼎鼎的AFNetworking的核心代码。我不希望将分析的生成的结果和源码文件混在一起，所以我创建了一个文件夹CallGraph并在该目录下调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd ./AFNetworking-master</span><br><span class="line">$ mkdir CallGraph</span><br><span class="line">$ cd ./CallGraph</span><br><span class="line">$ clang-mapper ../AFNetworking --</span><br></pre></td></tr></table></figure></p>
<p>之后程序会自动分析<code>../AFNetworking</code>下的所有代码文件，并在CallGraph目录下生成对应的png文件：<br><img src="/images/4.png" alt=""><br><img src="/images/5.png" alt=""></p>
<h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>clang-mapper提供了一些可选的命令行参数</p>
<ul>
<li><strong>-graph-only</strong>：只生成调用图png文件，不保留dot文件，这个是默认选项</li>
<li><strong>-dot-only</strong>：只生成dot文件，不生成png文件</li>
<li><strong>-dot-graph</strong>：同时生成dot文件和png文件</li>
<li><strong>-ignore-header</strong>：在iOS开发中头文件通常只用来声明，加上该选项可以忽略文件夹中的.h文件</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://clang.llvm.org/docs/LibASTMatchersTutorial.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/LibASTMatchersTutorial.html</a></li>
<li><a href="https://clang.llvm.org/docs/RAVFrontendAction.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/RAVFrontendAction.html</a></li>
<li><a href="https://clang.llvm.org/docs/LibASTMatchersReference.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/LibASTMatchersReference.html</a></li>
<li><a href="https://clang.llvm.org/docs/IntroductionToTheClangAST.html" target="_blank" rel="noopener">https://clang.llvm.org/docs/IntroductionToTheClangAST.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
